[
    {
        "question_id": 1,
        "code_file": "\n#include <iostream>\n#include <vector>\n\nint main() {\n    int N;\n    std::cin >> N;\n\n    std::vector<std::vector<int>> swaps(N, std::vector<int>(3));\n    for (int i = 0; i < N; ++i) {\n        std::cin >> swaps[i][0] >> swaps[i][1] >> swaps[i][2];\n    }\n\n    int max_score = 0;\n    for (int initial_position = 1; initial_position <= 3; ++initial_position) {\n        int score = 0;\n        int current_position = initial_position;\n        for (const auto& swap : swaps) {\n            if (current_position == swap[0]) {\n                current_position = swap[1];\n            } else if (current_position == swap[1]) {\n                current_position = swap[0];\n            }\n            if (current_position == swap[2]) {\n                ++score;\n            }\n        }\n        max_score = std::max(max_score, score);\n    }\n\n    std::cout << max_score << std::endl;\n\n    return 0;\n}\n"
    },
    {
        "question_id": 2,
        "code_file": "\n#include <iostream>\n#include <algorithm>\nusing namespace std;\n\nint main() {\n    int B, E, M;\n    cin >> B >> E >> M;\n\n    // Sort the positions to simplify calculations\n    sort(&B, &B + 3);\n\n    // Calculate the minimum number of moves\n    // If the largest gap is more than 2, only 1 move is needed\n    // If the largest gap is 2 and the positions are not already consecutive, 2 moves are needed\n    // Otherwise, at least 2 moves are needed\n    int min_moves = (M - B > 2) ? 1 : ((M - B == 2 && B + 1 != E) || (E + 1 != M) ? 2 : 2);\n\n    // Calculate the maximum number of moves\n    // The maximum number of moves is always 2, because the end points are always moved towards the center\n    int max_moves = 2;\n\n    cout << min_moves << endl;\n    cout << max_moves << endl;\n\n    return 0;\n}\n"
    }
]