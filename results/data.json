[
    {
        "question_id": 1,
        "code_file": "\n#include <iostream>\n#include <vector>\n\nint main() {\n    int N;\n    std::cin >> N;\n\n    std::vector<std::vector<int>> swaps(N, std::vector<int>(3));\n    for (int i = 0; i < N; ++i) {\n        std::cin >> swaps[i][0] >> swaps[i][1] >> swaps[i][2];\n    }\n\n    int max_score = 0;\n    for (int initial_position = 1; initial_position <= 3; ++initial_position) {\n        int score = 0;\n        int current_position = initial_position;\n        for (const auto& swap : swaps) {\n            if (swap[2] == current_position) {\n                ++score;\n            }\n            if (swap[0] == current_position) {\n                current_position = swap[1];\n            } else if (swap[1] == current_position) {\n                current_position = swap[0];\n            }\n        }\n        max_score = std::max(max_score, score);\n    }\n\n    std::cout << max_score << std::endl;\n\n    return 0;\n}\n"
    },
    {
        "question_id": 2,
        "code_file": "\n#include <iostream>\n#include <algorithm>\n#include <vector>\n\nint main() {\n    int b, e, m;\n    std::cin >> b >> e >> m;\n\n    std::vector<int> cows = {b, e, m};\n    std::sort(cows.begin(), cows.end());\n\n    // Calculate the minimum moves\n    int min_moves = 0;\n    if (cows[1] - cows[0] == 2) {\n        min_moves = 0;\n    } else if (cows[2] - cows[1] == 2) {\n        min_moves = 0;\n    } else {\n        min_moves = 1;\n    }\n\n    // Calculate the maximum moves\n    int max_moves = 2;\n    if (cows[2] - cows[1] == 2) {\n        max_moves = 1;\n    } else if (cows[1] - cows[0] == 2) {\n        max_moves = 1;\n    }\n\n    std::cout << min_moves << std::endl;\n    std::cout << max_moves << std::endl;\n\n    return 0;\n}\n"
    },
    {
        "question_id": 3,
        "code_file": "\n#include <iostream>\n#include <vector>\n#include <algorithm>\n\nusing namespace std;\n\nint main() {\n    int N;\n    cin >> N;\n    vector<vector<int>> adj(N + 1);\n    for (int i = 0; i < N - 1; ++i) {\n        int a, b;\n        cin >> a >> b;\n        adj[a].push_back(b);\n    }\n\n    for (int i = 1; i <= N; ++i) {\n        bool canReach = true;\n        for (int j = 1; j <= N; ++j) {\n            if (j == i) continue;\n            bool canReachFromJ = false;\n            vector<bool> visited(N + 1, false);\n            visited[j] = true;\n            queue<int> q;\n            q.push(j);\n            while (!q.empty()) {\n                int u = q.front();\n                q.pop();\n                for (int v : adj[u]) {\n                    if (!visited[v]) {\n                        visited[v] = true;\n                        q.push(v);\n                        if (v == i) {\n                            canReachFromJ = true;\n                            break;\n                        }\n                    }\n                }\n                if (canReachFromJ) break;\n            }\n            if (!canReachFromJ) {\n                canReach = false;\n                break;\n            }\n        }\n        if (canReach) {\n            cout << i << endl;\n            return 0;\n        }\n    }\n    cout << -1 << endl;\n    return 0;\n}\n"
    },
    {
        "question_id": 4,
        "code_file": "\n#include <iostream>\n#include <vector>\n#include <algorithm>\n\nusing namespace std;\n\nint main() {\n    int N, M, K;\n    cin >> N >> M >> K;\n\n    vector<int> hierarchy(N + 1, 0);\n    for (int i = 0; i < M; ++i) {\n        int cow;\n        cin >> cow;\n        hierarchy[cow] = i + 1;\n    }\n\n    vector<pair<int, int>> constraints(K);\n    for (int i = 0; i < K; ++i) {\n        cin >> constraints[i].first >> constraints[i].second;\n    }\n\n    // Sort constraints by position\n    sort(constraints.begin(), constraints.end(), [](const pair<int, int>& a, const pair<int, int>& b) {\n        return a.second < b.second;\n    });\n\n    int position = 1;\n    for (const auto& constraint : constraints) {\n        if (hierarchy[constraint.first] > position) {\n            position = hierarchy[constraint.first];\n        }\n        if (constraint.second > position) {\n            position = constraint.second;\n        }\n    }\n\n    cout << position << endl;\n\n    return 0;\n}\n"
    },
    {
        "question_id": 5,
        "code_file": "\n#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <climits>\n\nusing namespace std;\n\nconst int MAXN = 500;\nconst int MAXT = 4000000;\nconst int INF = INT_MAX;\n\nint n, m;\nint t[MAXN + 1];\nint dp[MAXT + 1];\n\nint main() {\n    // \u8bfb\u53d6\u8f93\u5165\n    cin >> n >> m;\n    for (int i = 1; i <= n; ++i) {\n        cin >> t[i];\n    }\n\n    // \u5bf9\u5230\u8fbe\u65f6\u95f4\u8fdb\u884c\u6392\u5e8f\n    sort(t + 1, t + n + 1);\n\n    // \u521d\u59cb\u5316dp\u6570\u7ec4\n    for (int i = 0; i <= MAXT; ++i) {\n        dp[i] = INF;\n    }\n    dp[0] = 0;\n\n    // \u52a8\u6001\u89c4\u5212\u6c42\u89e3\u6700\u5c0f\u7b49\u5f85\u65f6\u95f4\n    for (int i = 1; i <= n; ++i) {\n        for (int j = MAXT; j >= t[i]; --j) {\n            dp[j] = min(dp[j], dp[j - t[i]] + t[i]);\n        }\n    }\n\n    // \u8ba1\u7b97\u6700\u5c0f\u7b49\u5f85\u65f6\u95f4\u4e4b\u548c\n    int min_wait_time = INF;\n    for (int i = m; i <= MAXT; ++i) {\n        if (i % m == 0) {\n            min_wait_time = min(min_wait_time, dp[i]);\n        }\n    }\n\n    // \u8f93\u51fa\u7ed3\u679c\n    cout << min_wait_time << endl;\n\n    return 0;\n}\n"
    },
    {
        "question_id": 6,
        "code_file": "\n#include <iostream>\n#include <vector>\n#include <unordered_set>\n\nusing namespace std;\n\nint main() {\n    vector<vector<char>> board(3, vector<char>(3));\n    for (int i = 0; i < 3; ++i) {\n        for (int j = 0; j < 3; ++j) {\n            cin >> board[i][j];\n        }\n    }\n\n    int single_wins = 0;\n    int pair_wins = 0;\n\n    // Check rows and columns\n    for (int i = 0; i < 3; ++i) {\n        unordered_set<char> row_set;\n        unordered_set<char> col_set;\n        for (int j = 0; j < 3; ++j) {\n            row_set.insert(board[i][j]);\n            col_set.insert(board[j][i]);\n        }\n        if (row_set.size() == 1) {\n            ++single_wins;\n        }\n        if (col_set.size() == 1) {\n            ++single_wins;\n        }\n    }\n\n    // Check diagonals\n    unordered_set<char> diag1;\n    unordered_set<char> diag2;\n    for (int i = 0; i < 3; ++i) {\n        diag1.insert(board[i][i]);\n        diag2.insert(board[i][2 - i]);\n    }\n    if (diag1.size() == 1) {\n        ++single_wins;\n    }\n    if (diag2.size() == 1) {\n        ++single_wins;\n    }\n\n    // Check pairs\n    for (int i = 0; i < 3; ++i) {\n        for (int j = 0; j < 3; ++j) {\n            char c = board[i][j];\n            unordered_set<char> temp_set;\n            temp_set.insert(c);\n            // Check row\n            for (int k = 0; k < 3; ++k) {\n                if (k != j && board[i][k] == c) {\n                    temp_set.insert(board[i][k]);\n                }\n            }\n            // Check column\n            for (int k = 0; k < 3; ++k) {\n                if (k != i && board[k][j] == c) {\n                    temp_set.insert(board[k][j]);\n                }\n            }\n            // Check diagonals\n            if (i == j) {\n                for (int k = 0; k < 3; ++k) {\n                    if (k != i && board[k][k] == c) {\n                        temp_set.insert(board[k][k]);\n                    }\n                }\n            }\n            if (i + j == 2) {\n                for (int k = 0; k < 3; ++k) {\n                    if (k != i && board[k][2 - k] == c) {\n                        temp_set.insert(board[k][2 - k]);\n                    }\n                }\n            }\n            if (temp_set.size() == 2) {\n                ++pair_wins;\n            }\n        }\n    }\n\n    cout << single_wins << endl;\n    cout << pair_wins << endl;\n\n    return 0;\n}\n"
    },
    {
        "question_id": 7,
        "code_file": "\n#include <iostream>\n#include <cmath>\n\nint main() {\n    int n;\n    std::cin >> n;\n\n    // \u4ece2\u5f00\u59cb\u904d\u5386\u5230sqrt(n)\uff0c\u5bfb\u627en\u7684\u8d28\u56e0\u6570\n    for (int i = 2; i <= sqrt(n); ++i) {\n        if (n % i == 0) {\n            // \u627e\u5230\u4e00\u4e2a\u8d28\u56e0\u6570\uff0c\u8f93\u51fa\u8f83\u5927\u7684\u90a3\u4e2a\u8d28\u6570\n            std::cout << n / i << std::endl;\n            return 0;\n        }\n    }\n\n    // \u5982\u679c\u6ca1\u6709\u627e\u5230\u8d28\u56e0\u6570\uff0c\u8bf4\u660en\u672c\u8eab\u5c31\u662f\u8d28\u6570\n    // \u4f46\u6839\u636e\u9898\u610f\uff0cn\u662f\u4e24\u4e2a\u4e0d\u540c\u8d28\u6570\u7684\u4e58\u79ef\uff0c\u6240\u4ee5\u8fd9\u79cd\u60c5\u51b5\u4e0d\u4f1a\u53d1\u751f\n    return 0;\n}\n"
    },
    {
        "question_id": 8,
        "code_file": "\n#include <iostream>\n#include <vector>\n#include <algorithm>\n\nusing namespace std;\n\nstruct TreeNode {\n    int value;\n    int left;\n    int right;\n};\n\nint n;\nvector<TreeNode> tree;\nvector<int> maxSymmetricSubtreeSize;\n\nbool isSymmetric(int root1, int root2) {\n    if (root1 == -1 && root2 == -1) return true;\n    if (root1 == -1 || root2 == -1) return false;\n    if (tree[root1].value != tree[root2].value) return false;\n    return isSymmetric(tree[root1].left, tree[root2].right) && isSymmetric(tree[root1].right, tree[root2].left);\n}\n\nint countNodes(int root) {\n    if (root == -1) return 0;\n    return 1 + countNodes(tree[root].left) + countNodes(tree[root].right);\n}\n\nint findMaxSymmetricSubtreeSize(int root) {\n    if (maxSymmetricSubtreeSize[root] != -1) return maxSymmetricSubtreeSize[root];\n    if (root == -1) {\n        maxSymmetricSubtreeSize[root] = 0;\n        return 0;\n    }\n    int leftSize = findMaxSymmetricSubtreeSize(tree[root].left);\n    int rightSize = findMaxSymmetricSubtreeSize(tree[root].right);\n    int symmetricSize = 0;\n    if (isSymmetric(tree[root].left, tree[root].right)) {\n        symmetricSize = countNodes(root);\n    }\n    maxSymmetricSubtreeSize[root] = max({leftSize, rightSize, symmetricSize});\n    return maxSymmetricSubtreeSize[root];\n}\n\nint main() {\n    cin >> n;\n    tree.resize(n + 1);\n    maxSymmetricSubtreeSize.resize(n + 1, -1);\n\n    for (int i = 1; i <= n; ++i) {\n        cin >> tree[i].value;\n    }\n\n    for (int i = 1; i <= n; ++i) {\n        cin >> tree[i].left >> tree[i].right;\n    }\n\n    int result = findMaxSymmetricSubtreeSize(1);\n    cout << result << endl;\n\n    return 0;\n}\n"
    },
    {
        "question_id": 9,
        "code_file": "\n#include <iostream>\n#include <vector>\n#include <stack>\n#include <string>\n\nusing namespace std;\n\nconst int MOD = 10007;\n\n// \u5b9a\u4e49\u8fd0\u7b97\u7b26\u4f18\u5148\u7ea7\nint getPriority(char op) {\n    if (op == '*') return 1;\n    if (op == '+') return 0;\n    return -1;\n}\n\n// \u8ba1\u7b97\u4e24\u4e2a\u6570\u7684\u8fd0\u7b97\u7ed3\u679c\nint calculate(int a, int b, char op) {\n    if (op == '*') return (a * b) % MOD;\n    if (op == '+') return (a + b) % MOD;\n    return 0;\n}\n\n// \u8ba1\u7b97\u8868\u8fbe\u5f0f\u7684\u503c\nint evaluateExpression(const string& expression) {\n    stack<int> values;\n    stack<char> ops;\n    int n = expression.size();\n\n    for (int i = 0; i < n; ++i) {\n        if (expression[i] == '0' || expression[i] == '1') {\n            values.push(expression[i] - '0');\n        } else if (expression[i] == '(') {\n            ops.push(expression[i]);\n        } else if (expression[i] == ')') {\n            while (!ops.empty() && ops.top() != '(') {\n                int b = values.top(); values.pop();\n                int a = values.top(); values.pop();\n                char op = ops.top(); ops.pop();\n                values.push(calculate(a, b, op));\n            }\n            ops.pop(); // \u5f39\u51fa\u5de6\u62ec\u53f7\n        } else {\n            while (!ops.empty() && getPriority(ops.top()) >= getPriority(expression[i])) {\n                int b = values.top(); values.pop();\n                int a = values.top(); values.pop();\n                char op = ops.top(); ops.pop();\n                values.push(calculate(a, b, op));\n            }\n            ops.push(expression[i]);\n        }\n    }\n\n    while (!ops.empty()) {\n        int b = values.top(); values.pop();\n        int a = values.top(); values.pop();\n        char op = ops.top(); ops.pop();\n        values.push(calculate(a, b, op));\n    }\n\n    return values.top();\n}\n\nint main() {\n    int L;\n    string expression;\n\n    cin >> L;\n    cin >> expression;\n\n    // \u5728\u8868\u8fbe\u5f0f\u4e2d\u63d2\u5165\u5360\u4f4d\u7b26'_'\n    for (int i = 0; i < L; ++i) {\n        if (expression[i] == '(' || expression[i] == ')' || expression[i] == '+' || expression[i] == '*') {\n            expression.insert(i + 1, \"_\");\n            L += 2;\n            i += 2;\n        }\n    }\n\n    int result = evaluateExpression(expression);\n    cout << result << endl;\n\n    return 0;\n}\n"
    },
    {
        "question_id": 10,
        "code_file": "\n#include <iostream>\n#include <vector>\n#include <algorithm>\n\nusing namespace std;\n\nint main() {\n    int N, M;\n    cin >> N >> M;\n\n    vector<vector<int>> graph(N + 1);\n    for (int i = 0; i < M; ++i) {\n        int u, v;\n        cin >> u >> v;\n        graph[u].push_back(v);\n        graph[v].push_back(u);\n    }\n\n    vector<int> color(N + 1, 0);\n    vector<bool> visited(N + 1, false);\n\n    function<void(int)> dfs = [&](int u) {\n        visited[u] = true;\n        for (int v : graph[u]) {\n            if (!visited[v]) {\n                color[v] = 3 - color[u];\n                dfs(v);\n            }\n        }\n    };\n\n    for (int i = 1; i <= N; ++i) {\n        if (!visited[i]) {\n            color[i] = 1;\n            dfs(i);\n        }\n    }\n\n    for (int i = 1; i <= N; ++i) {\n        cout << color[i];\n    }\n    cout << endl;\n\n    return 0;\n}\n"
    },
    {
        "question_id": 11,
        "code_file": "\n#include <iostream>\n#include <vector>\n#include <algorithm>\n\nusing namespace std;\n\n// \u5b9a\u4e49\u9009\u624b\u7ed3\u6784\u4f53\nstruct Player {\n    int id;  // \u9009\u624b\u7f16\u53f7\n    int score;  // \u9009\u624b\u5206\u6570\n    int power;  // \u9009\u624b\u5b9e\u529b\u503c\n\n    // \u91cd\u8f7d\u5c0f\u4e8e\u8fd0\u7b97\u7b26\uff0c\u7528\u4e8e\u6392\u5e8f\n    bool operator<(const Player& other) const {\n        if (score != other.score) {\n            return score > other.score;  // \u5206\u6570\u9ad8\u7684\u6392\u524d\u9762\n        } else {\n            return id < other.id;  // \u5206\u6570\u76f8\u540c\uff0c\u7f16\u53f7\u5c0f\u7684\u6392\u524d\u9762\n        }\n    }\n};\n\n// \u5408\u5e76\u4e24\u4e2a\u6709\u5e8f\u6570\u7ec4\nvoid merge(vector<Player>& players, int left, int mid, int right) {\n    vector<Player> temp(right - left + 1);\n    int i = left, j = mid + 1, k = 0;\n\n    while (i <= mid && j <= right) {\n        if (players[i] < players[j]) {\n            temp[k++] = players[i++];\n        } else {\n            temp[k++] = players[j++];\n        }\n    }\n\n    while (i <= mid) {\n        temp[k++] = players[i++];\n    }\n\n    while (j <= right) {\n        temp[k++] = players[j++];\n    }\n\n    for (int p = 0; p < temp.size(); ++p) {\n        players[left + p] = temp[p];\n    }\n}\n\n// \u5f52\u5e76\u6392\u5e8f\nvoid mergeSort(vector<Player>& players, int left, int right) {\n    if (left < right) {\n        int mid = left + (right - left) / 2;\n        mergeSort(players, left, mid);\n        mergeSort(players, mid + 1, right);\n        merge(players, left, mid, right);\n    }\n}\n\nint main() {\n    int N, R, Q;\n    cin >> N >> R >> Q;\n\n    int numPlayers = 2 * N;\n    vector<Player> players(numPlayers);\n\n    // \u8bfb\u53d6\u521d\u59cb\u5206\u6570\n    for (int i = 0; i < numPlayers; ++i) {\n        cin >> players[i].score;\n        players[i].id = i + 1;\n    }\n\n    // \u8bfb\u53d6\u5b9e\u529b\u503c\n    for (int i = 0; i < numPlayers; ++i) {\n        cin >> players[i].power;\n    }\n\n    // \u6309\u521d\u59cb\u5206\u6570\u548c\u7f16\u53f7\u6392\u5e8f\n    mergeSort(players, 0, numPlayers - 1);\n\n    // \u8fdb\u884cR\u8f6e\u6bd4\u8d5b\n    for (int round = 0; round < R; ++round) {\n        vector<Player> winners, losers;\n\n        // \u6bcf\u8f6e\u6bd4\u8d5b\n        for (int i = 0; i < numPlayers; i += 2) {\n            if (players[i].power > players[i + 1].power) {\n                players[i].score += 1;\n                winners.push_back(players[i]);\n                losers.push_back(players[i + 1]);\n            } else {\n                players[i + 1].score += 1;\n                winners.push_back(players[i + 1]);\n                losers.push_back(players[i]);\n            }\n        }\n\n        // \u5408\u5e76\u80dc\u8005\u548c\u8d25\u8005\n        players = winners;\n        players.insert(players.end(), losers.begin(), losers.end());\n\n        // \u91cd\u65b0\u6392\u5e8f\n        mergeSort(players, 0, players.size() - 1);\n    }\n\n    // \u8f93\u51fa\u7b2cQ\u540d\u9009\u624b\u7684\u7f16\u53f7\n    cout << players[Q - 1].id << endl;\n\n    return 0;\n}\n"
    },
    {
        "question_id": 12,
        "code_file": "\n#include <iostream>\nusing namespace std;\n\nint main() {\n    int k;\n    cin >> k;\n    int total_coins = 0;\n    int day = 1;\n    int coins_per_day = 1;\n\n    while (k > 0) {\n        if (k >= day) {\n            total_coins += day * coins_per_day;\n            k -= day;\n        } else {\n            total_coins += k * coins_per_day;\n            k = 0;\n        }\n        day++;\n        coins_per_day++;\n    }\n\n    cout << total_coins << endl;\n    return 0;\n}\n"
    },
    {
        "question_id": 13,
        "code_file": "\n#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <climits>\n\nusing namespace std;\n\nconst int MOD = 1e9 + 7;\n\nint main() {\n    int N, K;\n    cin >> N >> K;\n    vector<vector<int>> grid(N, vector<int>(K));\n    vector<vector<int>> hor_costs(N, vector<int>(K - 1));\n    vector<vector<int>> ver_costs(N - 1, vector<int>(K));\n\n    // Read horizontal costs\n    for (int i = 0; i < N; ++i) {\n        for (int j = 0; j < K - 1; ++j) {\n            cin >> hor_costs[i][j];\n        }\n    }\n\n    // Read vertical costs\n    for (int i = 0; i < N - 1; ++i) {\n        for (int j = 0; j < K; ++j) {\n            cin >> ver_costs[i][j];\n        }\n    }\n\n    // Combine all costs into a single vector\n    vector<int> all_costs;\n    all_costs.reserve(N * (K - 1) + (N - 1) * K);\n    for (int i = 0; i < N; ++i) {\n        for (int j = 0; j < K - 1; ++j) {\n            all_costs.push_back(hor_costs[i][j]);\n        }\n    }\n    for (int i = 0; i < N - 1; ++i) {\n        for (int j = 0; j < K; ++j) {\n            all_costs.push_back(ver_costs[i][j]);\n        }\n    }\n\n    // Sort costs in ascending order\n    sort(all_costs.begin(), all_costs.end());\n\n    // Calculate the number of ways to form the minimum cost\n    long long ways = 1;\n    int min_cost = all_costs[0];\n    for (int cost : all_costs) {\n        if (cost == min_cost) {\n            ways++;\n        } else {\n            break;\n        }\n    }\n\n    // Output the result\n    cout << ways % MOD << endl;\n\n    return 0;\n}\n"
    },
    {
        "question_id": 14,
        "code_file": "\n#include <iostream>\nusing namespace std;\n\nint main() {\n    int n, a, b, c, d, e, f;\n    cin >> n >> a >> b >> c >> d >> e >> f;\n\n    // \u8ba1\u7b97\u6bcf\u79cd\u5305\u88c5\u81f3\u5c11\u9700\u8981\u8d2d\u4e70\u7684\u4e2a\u6570\n    int num1 = (n + a - 1) / a; // \u5411\u4e0a\u53d6\u6574\n    int num2 = (n + b - 1) / b;\n    int num3 = (n + c - 1) / c;\n\n    // \u8ba1\u7b97\u6bcf\u79cd\u5305\u88c5\u7684\u603b\u82b1\u8d39\n    int cost1 = num1 * d;\n    int cost2 = num2 * e;\n    int cost3 = num3 * f;\n\n    // \u627e\u51fa\u6700\u5c0f\u7684\u82b1\u8d39\n    int min_cost = min(cost1, min(cost2, cost3));\n\n    // \u8f93\u51fa\u7ed3\u679c\n    cout << min_cost << endl;\n\n    return 0;\n}\n"
    },
    {
        "question_id": 15,
        "code_file": "\n#include <iostream>\nusing namespace std;\n\nint main() {\n    int n;\n    cin >> n;\n    int ans = 0;\n    for (int i = 1; i <= n; i++) {\n        ans += (1 << i) + (1 << i) - 2;\n    }\n    cout << ans << endl;\n    return 0;\n}\n"
    },
    {
        "question_id": 16,
        "code_file": "\n#include <iostream>\n#include <vector>\n#include <algorithm>\n\nusing namespace std;\n\nstruct Sensor {\n    string type;\n    int lower;\n    int upper;\n};\n\nint main() {\n    int N;\n    cin >> N;\n    vector<Sensor> sensors(N);\n\n    for (int i = 0; i < N; ++i) {\n        cin >> sensors[i].type >> sensors[i].lower >> sensors[i].upper;\n    }\n\n    int minBefore = 0;\n    int maxBefore = 1000;\n    int minAfter = 0;\n    int maxAfter = 1000;\n\n    for (int i = 0; i < N; ++i) {\n        if (sensors[i].type == \"on\") {\n            minBefore = max(minBefore, sensors[i].lower);\n            maxBefore = min(maxBefore, sensors[i].upper);\n        } else if (sensors[i].type == \"off\") {\n            minAfter = max(minAfter, sensors[i].lower);\n            maxAfter = min(maxAfter, sensors[i].upper);\n        }\n    }\n\n    cout << minBefore << \" \" << maxBefore << endl;\n    cout << minAfter << \" \" << maxAfter << endl;\n\n    return 0;\n}\n"
    },
    {
        "question_id": 17,
        "code_file": "\n#include <iostream>\n#include <algorithm>\n\nusing namespace std;\n\n// \u6269\u5c55\u6b27\u51e0\u91cc\u5f97\u7b97\u6cd5\uff0c\u7528\u4e8e\u6c42\u89e3 ax + by = gcd(a, b)\nlong long exgcd(long long a, long long b, long long &x, long long &y) {\n    if (b == 0) {\n        x = 1;\n        y = 0;\n        return a;\n    }\n    long long d = exgcd(b, a % b, x, y);\n    long long temp = x;\n    x = y;\n    y = temp - (a / b) * y;\n    return d;\n}\n\nint main() {\n    long long a, b;\n    cin >> a >> b;\n\n    long long x, y;\n    long long gcd = exgcd(a, b, x, y);\n\n    // \u5c06\u89e3\u8c03\u6574\u5230\u6700\u5c0f\u6b63\u6574\u6570\u89e3\n    x = (x % b + b) % b;\n\n    cout << x << endl;\n\n    return 0;\n}\n"
    },
    {
        "question_id": 18,
        "code_file": "\n#include <iostream>\n#include <vector>\n#include <string>\n\nusing namespace std;\n\n// \u5b9a\u4e49\u65b9\u5411\u6570\u7ec4\uff0c\u8868\u793a\u516b\u4e2a\u65b9\u5411\u7684\u79fb\u52a8\nconst int dx[8] = {-1, -1, -1, 0, 0, 1, 1, 1};\nconst int dy[8] = {-1, 0, 1, -1, 1, -1, 0, 1};\n\nint main() {\n    int n, m;\n    cin >> n >> m;\n\n    // \u521d\u59cb\u5316\u96f7\u533a\u548c\u7ed3\u679c\u6570\u7ec4\n    vector<vector<char>> mine(n, vector<char>(m));\n    vector<vector<int>> result(n, vector<int>(m));\n\n    // \u8bfb\u53d6\u8f93\u5165\u7684\u96f7\u533a\u5206\u5e03\n    for (int i = 0; i < n; ++i) {\n        for (int j = 0; j < m; ++j) {\n            cin >> mine[i][j];\n        }\n    }\n\n    // \u904d\u5386\u6bcf\u4e2a\u683c\u5b50\uff0c\u8ba1\u7b97\u975e\u5730\u96f7\u683c\u5468\u56f4\u7684\u5730\u96f7\u6570\n    for (int i = 0; i < n; ++i) {\n        for (int j = 0; j < m; ++j) {\n            if (mine[i][j] == '*') {\n                result[i][j] = '*';\n            } else {\n                int count = 0;\n                for (int k = 0; k < 8; ++k) {\n                    int ni = i + dx[k];\n                    int nj = j + dy[k];\n                    // \u68c0\u67e5\u8fb9\u754c\u6761\u4ef6\n                    if (ni >= 0 && ni < n && nj >= 0 && nj < m && mine[ni][nj] == '*') {\n                        ++count;\n                    }\n                }\n                result[i][j] = count;\n            }\n        }\n    }\n\n    // \u8f93\u51fa\u7ed3\u679c\n    for (int i = 0; i < n; ++i) {\n        for (int j = 0; j < m; ++j) {\n            if (result[i][j] == '*') {\n                cout << '*';\n            } else {\n                cout << result[i][j];\n            }\n        }\n        cout << endl;\n    }\n\n    return 0;\n}\n"
    },
    {
        "question_id": 19,
        "code_file": "\n#include <iostream>\n#include <string>\nusing namespace std;\n\nint main() {\n    string isbn;\n    cin >> isbn;\n\n    // \u63d0\u53d6ISBN\u53f7\u7801\u4e2d\u7684\u6570\u5b57\u90e8\u5206\n    string digits = isbn.substr(0, isbn.size() - 2);\n\n    // \u8ba1\u7b97\u8bc6\u522b\u7801\n    int sum = 0;\n    for (int i = 0; i < digits.size(); ++i) {\n        sum += (digits[i] - '0') * (i + 1);\n    }\n\n    // \u8ba1\u7b97\u8bc6\u522b\u7801\u7684\u503c\n    char check_digit;\n    int mod = sum % 11;\n    if (mod == 10) {\n        check_digit = 'X';\n    } else {\n        check_digit = '0' + mod;\n    }\n\n    // \u68c0\u67e5\u8f93\u5165\u7684\u8bc6\u522b\u7801\u662f\u5426\u6b63\u786e\n    if (check_digit == isbn.back()) {\n        cout << \"Right\" << endl;\n    } else {\n        // \u751f\u6210\u6b63\u786e\u7684ISBN\u53f7\u7801\n        string correct_isbn = isbn.substr(0, isbn.size() - 1) + check_digit;\n        cout << correct_isbn << endl;\n    }\n\n    return 0;\n}\n"
    },
    {
        "question_id": 20,
        "code_file": "\n#include <iostream>\n#include <vector>\n#include <queue>\n#include <tuple>\n\nusing namespace std;\n\nconst int MAXN = 751;\nint N;\nint heights[MAXN][MAXN];\nbool visited[MAXN][MAXN];\nint dx[8] = {-1, -1, -1, 0, 0, 1, 1, 1};\nint dy[8] = {-1, 0, 1, -1, 1, -1, 0, 1};\n\nstruct Cell {\n    int x, y, height;\n};\n\nbool isValid(int x, int y) {\n    return x >= 0 && x < N && y >= 0 && y < N;\n}\n\nbool isValley(int x, int y) {\n    for (int i = 0; i < 8; ++i) {\n        int nx = x + dx[i];\n        int ny = y + dy[i];\n        if (isValid(nx, ny) && heights[nx][ny] <= heights[x][y]) {\n            return false;\n        }\n    }\n    return true;\n}\n\nint bfs(int startX, int startY) {\n    queue<tuple<int, int, int>> q;\n    q.push({startX, startY, heights[startX][startY]});\n    visited[startX][startY] = true;\n    int size = 0;\n\n    while (!q.empty()) {\n        auto [x, y, height] = q.front();\n        q.pop();\n        size++;\n\n        for (int i = 0; i < 4; ++i) {\n            int nx = x + dx[i];\n            int ny = y + dy[i];\n            if (isValid(nx, ny) && !visited[nx][ny] && heights[nx][ny] < height && isValley(nx, ny)) {\n                visited[nx][ny] = true;\n                q.push({nx, ny, heights[nx][ny]});\n            }\n        }\n    }\n\n    return size;\n}\n\nint main() {\n    cin >> N;\n    for (int i = 0; i < N; ++i) {\n        for (int j = 0; j < N; ++j) {\n            cin >> heights[i][j];\n        }\n    }\n\n    int totalValleySize = 0;\n\n    for (int i = 0; i < N; ++i) {\n        for (int j = 0; j < N; ++j) {\n            if (!visited[i][j] && isValley(i, j)) {\n                totalValleySize += bfs(i, j);\n            }\n        }\n    }\n\n    cout << totalValleySize << endl;\n\n    return 0;\n}\n"
    },
    {
        "question_id": 21,
        "code_file": "\n#include <iostream>\n#include <vector>\n#include <algorithm>\n\nusing namespace std;\n\n// \u5b9a\u4e49\u4e00\u4e2a\u7ed3\u6784\u4f53\u6765\u8868\u793a\u8fb9\nstruct Edge {\n    int u, v;\n};\n\n// \u6bd4\u8f83\u51fd\u6570\uff0c\u7528\u4e8e\u5bf9\u8fb9\u8fdb\u884c\u6392\u5e8f\nbool compareEdges(const Edge &a, const Edge &b) {\n    if (a.u != b.u) return a.u < b.u;\n    return a.v < b.v;\n}\n\nint main() {\n    int n, m;\n    cin >> n >> m;\n\n    vector<vector<int>> stops(m + 1);\n    vector<Edge> edges;\n\n    // \u8bfb\u53d6\u8f93\u5165\u6570\u636e\n    for (int i = 1; i <= m; ++i) {\n        int s;\n        cin >> s;\n        for (int j = 0; j < s; ++j) {\n            int station;\n            cin >> station;\n            stops[i].push_back(station);\n        }\n    }\n\n    // \u6784\u5efa\u8fb9\u96c6\n    for (int i = 1; i <= m; ++i) {\n        for (int j = 0; j < stops[i].size(); ++j) {\n            for (int k = j + 1; k < stops[i].size(); ++k) {\n                edges.push_back({stops[i][j], stops[i][k]});\n            }\n        }\n    }\n\n    // \u5bf9\u8fb9\u96c6\u8fdb\u884c\u6392\u5e8f\n    sort(edges.begin(), edges.end(), compareEdges);\n\n    // Kruskal\u7b97\u6cd5\u6c42\u6700\u5c0f\u751f\u6210\u6811\n    vector<int> parent(n + 1);\n    for (int i = 1; i <= n; ++i) {\n        parent[i] = i;\n    }\n\n    int levels = 1;\n    int edgeCount = 0;\n\n    for (const auto &edge : edges) {\n        int rootU = edge.u;\n        int rootV = edge.v;\n\n        // \u627e\u5230\u4e24\u4e2a\u9876\u70b9\u7684\u6839\n        while (rootU != parent[rootU]) {\n            rootU = parent[rootU];\n        }\n        while (rootV != parent[rootV]) {\n            rootV = parent[rootV];\n        }\n\n        // \u5982\u679c\u4e24\u4e2a\u9876\u70b9\u4e0d\u5728\u540c\u4e00\u4e2a\u96c6\u5408\u4e2d\uff0c\u5219\u5408\u5e76\u5b83\u4eec\n        if (rootU != rootV) {\n            parent[rootV] = rootU;\n            edgeCount++;\n        }\n\n        // \u5982\u679c\u5df2\u7ecf\u8fde\u63a5\u4e86n-1\u6761\u8fb9\uff0c\u5219\u6240\u6709\u70b9\u5df2\u7ecf\u8fde\u901a\n        if (edgeCount == n - 1) {\n            break;\n        }\n    }\n\n    // \u8f93\u51fa\u6700\u5c11\u5212\u5206\u7684\u7ea7\u522b\u6570\n    cout << levels << endl;\n\n    return 0;\n}\n"
    },
    {
        "question_id": 22,
        "code_file": "\n#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <numeric>\n\nusing namespace std;\n\n// \u5b9a\u4e49\u5927\u81e3\u7ed3\u6784\u4f53\nstruct Minister {\n    int left;\n    int right;\n};\n\n// \u6bd4\u8f83\u51fd\u6570\uff0c\u7528\u4e8e\u6392\u5e8f\nbool compareMinisters(const Minister &a, const Minister &b) {\n    return a.left * b.right < b.left * a.right;\n}\n\nint main() {\n    int n;\n    cin >> n;\n    \n    vector<Minister> ministers(n);\n    ministers[0].left = 1; // \u56fd\u738b\u7684\u5de6\u624b\u6570\u521d\u59cb\u5316\u4e3a1\n    ministers[0].right = 1; // \u56fd\u738b\u7684\u53f3\u624b\u6570\u521d\u59cb\u5316\u4e3a1\n    \n    for (int i = 1; i <= n; ++i) {\n        cin >> ministers[i].left >> ministers[i].right;\n    }\n    \n    // \u6309\u7167\u6bd4\u8f83\u51fd\u6570\u6392\u5e8f\n    sort(ministers.begin() + 1, ministers.end(), compareMinisters);\n    \n    // \u8ba1\u7b97\u4e58\u79ef\n    long long product = 1;\n    vector<long long> rewards(n + 1);\n    \n    for (int i = 1; i <= n; ++i) {\n        product *= ministers[i - 1].left;\n        rewards[i] = product / ministers[i].right;\n    }\n    \n    // \u627e\u5230\u6700\u5927\u5956\u52b1\n    long long maxReward = *max_element(rewards.begin(), rewards.end());\n    \n    cout << maxReward << endl;\n    \n    return 0;\n}\n"
    },
    {
        "question_id": 23,
        "code_file": "\n#include <iostream>\n#include <vector>\n#include <unordered_map>\n\nusing namespace std;\n\nconst int MOD = 10007;\n\nint main() {\n    int n, m;\n    cin >> n >> m;\n\n    vector<int> number(n + 1);\n    vector<int> color(n + 1);\n\n    for (int i = 1; i <= n; ++i) {\n        cin >> number[i];\n    }\n\n    for (int i = 1; i <= n; ++i) {\n        cin >> color[i];\n    }\n\n    vector<vector<int>> cnt(m + 1, vector<int>(n + 1, 0));\n    vector<vector<int>> sum(m + 1, vector<int>(n + 1, 0));\n\n    for (int i = 1; i <= n; ++i) {\n        int c = color[i];\n        int num = number[i];\n        for (int j = 1; j <= i; ++j) {\n            if (color[j] == c) {\n                cnt[c][i] += cnt[c][j];\n                sum[c][i] = (sum[c][i] + sum[c][j] + cnt[c][j] * num) % MOD;\n                cnt[c][i]++;\n            }\n        }\n    }\n\n    int result = 0;\n    for (int i = 1; i <= n; ++i) {\n        result = (result + sum[color[i]][i]) % MOD;\n    }\n\n    cout << result << endl;\n\n    return 0;\n}\n"
    },
    {
        "question_id": 24,
        "code_file": "\n#include <iostream>\n#include <vector>\n#include <algorithm>\n\nint main() {\n    int N;\n    std::cin >> N;\n    std::vector<int> cows(N);\n    for (int i = 0; i < N; ++i) {\n        std::cin >> cows[i];\n    }\n\n    int operations = 0;\n    for (int i = 0; i < N; ++i) {\n        if (cows[i] != i + 1) {\n            int j = i;\n            while (j < N && cows[j] != i + 1) {\n                ++j;\n            }\n            std::rotate(cows.begin() + i, cows.begin() + j, cows.begin() + j + 1);\n            ++operations;\n        }\n    }\n\n    std::cout << operations << std::endl;\n    return 0;\n}\n"
    },
    {
        "question_id": 25,
        "code_file": "\n#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <climits>\n\nusing namespace std;\n\nint main() {\n    int n, p;\n    cin >> n >> p;\n    vector<int> nums(n);\n    for (int i = 0; i < n; ++i) {\n        cin >> nums[i];\n    }\n\n    // \u7279\u5f81\u503c\u6570\u7ec4\n    vector<int> features(n);\n    // \u5f53\u524d\u6700\u5927\u8fde\u7eed\u5b50\u6570\u7ec4\u548c\n    int current_max = nums[0];\n    features[0] = nums[0];\n\n    // \u8ba1\u7b97\u6bcf\u4e2a\u5c0f\u670b\u53cb\u7684\u7279\u5f81\u503c\n    for (int i = 1; i < n; ++i) {\n        current_max = max(nums[i], current_max + nums[i]);\n        features[i] = current_max;\n    }\n\n    // \u8ba1\u7b97\u6bcf\u4e2a\u5c0f\u670b\u53cb\u7684\u5206\u6570\n    vector<int> scores(n);\n    scores[0] = features[0];\n    int max_score = scores[0];\n\n    for (int i = 1; i < n; ++i) {\n        scores[i] = scores[i - 1] + features[i];\n        max_score = max(max_score, scores[i]);\n    }\n\n    // \u8f93\u51fa\u6700\u5927\u5206\u6570\u5bf9 p \u53d6\u6a21\u7684\u7ed3\u679c\n    cout << (max_score % p + p) % p << endl;\n\n    return 0;\n}\n"
    },
    {
        "question_id": 26,
        "code_file": "\n#include <iostream>\n#include <vector>\n#include <string>\n\nusing namespace std;\n\nint main() {\n    int N;\n    cin >> N;\n    vector<string> grid(N);\n    for (int i = 0; i < N; ++i) {\n        cin >> grid[i];\n    }\n\n    // Check each cow to see if flipping it would make all cows face the same direction\n    for (int i = 0; i < N; ++i) {\n        for (int j = 0; j < N; ++j) {\n            bool allSameDirection = true;\n            char targetDirection = grid[i][j];\n\n            // Flip the cow at (i, j)\n            for (int k = 0; k < N; ++k) {\n                if (grid[i][k] != targetDirection) {\n                    allSameDirection = false;\n                    break;\n                }\n                if (grid[k][j] != targetDirection) {\n                    allSameDirection = false;\n                    break;\n                }\n            }\n\n            if (allSameDirection) {\n                cout << i + 1 << \" \" << j + 1 << endl;\n                return 0;\n            }\n        }\n    }\n\n    // If no single cow can be flipped to make all cows face the same direction\n    cout << -1 << endl;\n    return 0;\n}\n"
    },
    {
        "question_id": 27,
        "code_file": "\n#include <iostream>\n#include <string>\nusing namespace std;\n\nint main() {\n    string key, cipher;\n    cin >> key >> cipher;\n\n    // \u5c06\u5bc6\u94a5\u8f6c\u6362\u4e3a\u5c0f\u5199\n    for (char &c : key) {\n        if (c >= 'A' && c <= 'Z') {\n            c = c - 'A' + 'a';\n        }\n    }\n\n    string plaintext = \"\";\n    int keyIndex = 0;\n\n    // \u904d\u5386\u5bc6\u6587\uff0c\u89e3\u5bc6\u6bcf\u4e2a\u5b57\u7b26\n    for (char c : cipher) {\n        if (c >= 'A' && c <= 'Z') {\n            // \u5982\u679c\u5bc6\u6587\u662f\u5927\u5199\u5b57\u6bcd\uff0c\u5bc6\u94a5\u662f\u5927\u5199\u5b57\u6bcd\n            plaintext += (c - key[keyIndex] + 26) % 26 + 'A';\n        } else if (c >= 'a' && c <= 'z') {\n            // \u5982\u679c\u5bc6\u6587\u662f\u5c0f\u5199\u5b57\u6bcd\uff0c\u5bc6\u94a5\u662f\u5c0f\u5199\u5b57\u6bcd\n            plaintext += (c - key[keyIndex] + 26) % 26 + 'a';\n        }\n        keyIndex = (keyIndex + 1) % key.size();\n    }\n\n    cout << plaintext << endl;\n    return 0;\n}\n"
    },
    {
        "question_id": 28,
        "code_file": "\n#include <iostream>\n#include <vector>\n\nusing namespace std;\n\nint main() {\n    int n, m;\n    cin >> n >> m;\n\n    // \u521d\u59cb\u5316\u4e00\u4e2a\u4e8c\u7ef4\u6570\u7ec4dp\uff0cdp[i][j]\u8868\u793a\u7b2ci\u6b21\u4f20\u7403\u540e\uff0c\u7403\u5728\u7b2cj\u4e2a\u540c\u5b66\u624b\u91cc\u7684\u65b9\u6cd5\u6570\n    vector<vector<int>> dp(m + 1, vector<int>(n, 0));\n    dp[0][0] = 1; // \u521d\u59cb\u72b6\u6001\uff0c\u7403\u5728\u5c0f\u86ee\u624b\u91cc\n\n    // \u52a8\u6001\u89c4\u5212\u8ba1\u7b97\u6bcf\u6b21\u4f20\u7403\u540e\u7684\u65b9\u6cd5\u6570\n    for (int i = 1; i <= m; ++i) {\n        for (int j = 0; j < n; ++j) {\n            // \u7403\u53ef\u4ee5\u4ece\u5de6\u8fb9\u4f20\u8fc7\u6765\n            if (j > 0) {\n                dp[i][j] += dp[i - 1][j - 1];\n            } else {\n                dp[i][j] += dp[i - 1][n - 1];\n            }\n            // \u7403\u53ef\u4ee5\u4ece\u53f3\u8fb9\u4f20\u8fc7\u6765\n            if (j < n - 1) {\n                dp[i][j] += dp[i - 1][j + 1];\n            } else {\n                dp[i][j] += dp[i - 1][0];\n            }\n        }\n    }\n\n    // \u8f93\u51fa\u7b2cm\u6b21\u4f20\u7403\u540e\uff0c\u7403\u5728\u5c0f\u86ee\u624b\u91cc\u7684\u65b9\u6cd5\u6570\n    cout << dp[m][0] << endl;\n\n    return 0;\n}\n"
    },
    {
        "question_id": 29,
        "code_file": "\n#include <iostream>\n#include <vector>\n#include <algorithm>\n\nusing namespace std;\n\nstruct House {\n    int distance;\n    int fatigue;\n};\n\nbool compareByFatigue(const House &a, const House &b) {\n    return a.fatigue > b.fatigue;\n}\n\nint main() {\n    int N;\n    cin >> N;\n\n    vector<House> houses(N);\n    for (int i = 0; i < N; ++i) {\n        cin >> houses[i].distance;\n    }\n\n    for (int i = 0; i < N; ++i) {\n        cin >> houses[i].fatigue;\n    }\n\n    // \u6309\u7167\u63a8\u9500\u75b2\u52b3\u503c\u4ece\u5927\u5230\u5c0f\u6392\u5e8f\n    sort(houses.begin(), houses.end(), compareByFatigue);\n\n    vector<int> maxFatigue(N);\n    int totalDistance = houses[0].distance * 2; // \u521d\u59cb\u8ddd\u79bb\u4e3a\u7b2c\u4e00\u4e2a\u4f4f\u6237\u7684\u8ddd\u79bb\u4e58\u4ee52\n    maxFatigue[0] = houses[0].fatigue + totalDistance;\n\n    for (int i = 1; i < N; ++i) {\n        totalDistance += houses[i].distance * 2; // \u66f4\u65b0\u603b\u8ddd\u79bb\n        maxFatigue[i] = maxFatigue[i - 1] + houses[i].fatigue + totalDistance;\n    }\n\n    for (int i = 0; i < N; ++i) {\n        cout << maxFatigue[i] << endl;\n    }\n\n    return 0;\n}\n"
    },
    {
        "question_id": 30,
        "code_file": "\n#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <climits>\n\nusing namespace std;\n\nstruct Point {\n    long long x, y;\n};\n\nstruct Edge {\n    int u, v;\n};\n\nvector<Point> cows;\nvector<Edge> edges;\nvector<int> parent;\nvector<int> rank;\n\nint find(int x) {\n    if (parent[x] != x) {\n        parent[x] = find(parent[x]);\n    }\n    return parent[x];\n}\n\nvoid unite(int x, int y) {\n    int rootX = find(x);\n    int rootY = find(y);\n    if (rootX != rootY) {\n        if (rank[rootX] > rank[rootY]) {\n            parent[rootY] = rootX;\n        } else if (rank[rootX] < rank[rootY]) {\n            parent[rootX] = rootY;\n        } else {\n            parent[rootY] = rootX;\n            rank[rootX]++;\n        }\n    }\n}\n\nint main() {\n    int N, M;\n    cin >> N >> M;\n\n    cows.resize(N);\n    parent.resize(N);\n    rank.resize(N, 0);\n\n    for (int i = 0; i < N; ++i) {\n        cin >> cows[i].x >> cows[i].y;\n        parent[i] = i;\n    }\n\n    edges.resize(M);\n    for (int i = 0; i < M; ++i) {\n        cin >> edges[i].u >> edges[i].v;\n        edges[i].u--; // Convert to 0-based index\n        edges[i].v--; // Convert to 0-based index\n        unite(edges[i].u, edges[i].v);\n    }\n\n    vector<int> componentSize(N, 0);\n    for (int i = 0; i < N; ++i) {\n        componentSize[find(i)]++;\n    }\n\n    long long minX = LLONG_MAX, maxX = LLONG_MIN;\n    long long minY = LLONG_MAX, maxY = LLONG_MIN;\n\n    for (int i = 0; i < N; ++i) {\n        if (componentSize[find(i)] > 1) {\n            minX = min(minX, cows[i].x);\n            maxX = max(maxX, cows[i].x);\n            minY = min(minY, cows[i].y);\n            maxY = max(maxY, cows[i].y);\n        }\n    }\n\n    if (minX == LLONG_MAX || minY == LLONG_MAX) {\n        cout << 0 << endl;\n    } else {\n        cout << 2 * (maxX - minX + maxY - minY) << endl;\n    }\n\n    return 0;\n}\n"
    },
    {
        "question_id": 31,
        "code_file": "\n#include <iostream>\n#include <vector>\n#include <string>\n#include <unordered_map>\n#include <algorithm>\n\nusing namespace std;\n\nint main() {\n    int N;\n    cin >> N;\n    vector<string> animals(N);\n    vector<vector<string>> features(N);\n    unordered_map<string, int> featureCount;\n\n    for (int i = 0; i < N; ++i) {\n        cin >> animals[i];\n        int K;\n        cin >> K;\n        features[i].resize(K);\n        for (int j = 0; j < K; ++j) {\n            cin >> features[i][j];\n            featureCount[features[i][j]]++;\n        }\n    }\n\n    int maxYesAnswers = 0;\n\n    for (const auto& animal : animals) {\n        int yesAnswers = 0;\n        for (const auto& feature : features) {\n            for (const auto& f : feature) {\n                if (featureCount[f] == 1) {\n                    yesAnswers++;\n                    break;\n                }\n            }\n        }\n        maxYesAnswers = max(maxYesAnswers, yesAnswers);\n    }\n\n    cout << maxYesAnswers << endl;\n\n    return 0;\n}\n"
    },
    {
        "question_id": 32,
        "code_file": "\n#include <iostream>\n#include <vector>\n#include <unordered_map>\n\nusing namespace std;\n\nint main() {\n    int n, m;\n    cin >> n >> m;\n\n    vector<int> X(m);\n    for (int i = 0; i < m; ++i) {\n        cin >> X[i];\n    }\n\n    vector<vector<int>> result(m, vector<int>(4, 0));\n\n    // \u4f7f\u7528\u54c8\u5e0c\u8868\u6765\u8bb0\u5f55\u6bcf\u4e2a\u9b54\u6cd5\u503c\u7684\u6570\u91cf\n    unordered_map<int, int> count;\n\n    // \u904d\u5386\u6bcf\u4e2a\u9b54\u6cd5\u503c\uff0c\u8ba1\u7b97\u5176\u4f5c\u4e3aA, B, C, D\u7684\u6b21\u6570\n    for (int i = 0; i < m; ++i) {\n        int x = X[i];\n        int a = count[x - 1];\n        int b = count[x - 5];\n        int c = count[x + 1];\n        int d = count[x + 5];\n\n        result[i][0] = a;\n        result[i][1] = b;\n        result[i][2] = c;\n        result[i][3] = d;\n\n        // \u66f4\u65b0\u54c8\u5e0c\u8868\n        count[x]++;\n    }\n\n    // \u8f93\u51fa\u7ed3\u679c\n    for (int i = 0; i < m; ++i) {\n        cout << result[i][0] << \" \" << result[i][1] << \" \" << result[i][2] << \" \" << result[i][3] << endl;\n    }\n\n    return 0;\n}\n"
    },
    {
        "question_id": 33,
        "code_file": "\n#include <iostream>\n#include <vector>\n#include <string>\n\nusing namespace std;\n\nint main() {\n    int n;\n    cin >> n;\n    vector<int> coefficients(n + 1);\n    for (int i = 0; i <= n; ++i) {\n        cin >> coefficients[i];\n    }\n\n    string result;\n    for (int i = n; i >= 0; --i) {\n        if (coefficients[i] != 0) {\n            if (!result.empty() && coefficients[i] > 0) {\n                result += \"+\";\n            }\n\n            if (coefficients[i] < 0) {\n                result += \"-\";\n                coefficients[i] = -coefficients[i];\n            }\n\n            if (i > 0) {\n                result += to_string(coefficients[i]);\n            }\n\n            if (i == 1) {\n                result += \"x\";\n            } else if (i > 1) {\n                result += \"x^\" + to_string(i);\n            }\n        }\n    }\n\n    cout << result << endl;\n    return 0;\n}\n"
    },
    {
        "question_id": 34,
        "code_file": "\n#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <climits>\n\nusing namespace std;\n\nconst int MAXN = 16;\nconst int MAXM = 16;\nconst int INF = INT_MAX;\n\nint n, m, r, c;\nint matrix[MAXN][MAXM];\nint dp[1 << MAXN][1 << MAXM];\n\n// \u8ba1\u7b97\u5b50\u77e9\u9635\u7684\u5206\u503c\nint calculateScore(const vector<int>& rows, const vector<int>& cols) {\n    int score = 0;\n    for (int i = 0; i < rows.size(); ++i) {\n        for (int j = 0; j < cols.size(); ++j) {\n            if (j > 0) {\n                score += abs(matrix[rows[i]][cols[j]] - matrix[rows[i]][cols[j-1]]);\n            }\n            if (i > 0) {\n                score += abs(matrix[rows[i]][cols[j]] - matrix[rows[i-1]][cols[j]]);\n            }\n        }\n    }\n    return score;\n}\n\n// \u6df1\u5ea6\u4f18\u5148\u641c\u7d22\nvoid dfs(int row, int col, int mask, int& minScore) {\n    if (row == r) {\n        minScore = min(minScore, calculateScore(selectedRows, selectedCols));\n        return;\n    }\n    if (col == c) {\n        selectedRows.push_back(row);\n        dfs(row + 1, 0, mask, minScore);\n        selectedRows.pop_back();\n        return;\n    }\n    if ((mask & (1 << col)) == 0) {\n        selectedCols.push_back(col);\n        dfs(row, col + 1, mask, minScore);\n        selectedCols.pop_back();\n    }\n    dfs(row, col + 1, mask, minScore);\n}\n\nint main() {\n    cin >> n >> m >> r >> c;\n    for (int i = 0; i < n; ++i) {\n        for (int j = 0; j < m; ++j) {\n            cin >> matrix[i][j];\n        }\n    }\n\n    vector<int> selectedRows, selectedCols;\n    int minScore = INF;\n    dfs(0, 0, (1 << m) - 1, minScore);\n\n    cout << minScore << endl;\n    return 0;\n}\n"
    },
    {
        "question_id": 35,
        "code_file": "\n#include <iostream>\n#include <vector>\n#include <algorithm>\n\nusing namespace std;\n\n// \u8ba1\u7b97\u6700\u5927\u516c\u7ea6\u6570\nint gcd(int a, int b) {\n    while (b != 0) {\n        int t = b;\n        b = a % b;\n        a = t;\n    }\n    return a;\n}\n\n// \u8ba1\u7b97\u6700\u5c0f\u516c\u500d\u6570\nint lcm(int a, int b) {\n    return a / gcd(a, b) * b;\n}\n\n// \u8ba1\u7b97\u8d28\u56e0\u6570\u5206\u89e3\nvoid primeFactorization(int n, vector<int>& factors) {\n    for (int i = 2; i * i <= n; ++i) {\n        while (n % i == 0) {\n            factors[i]++;\n            n /= i;\n        }\n    }\n    if (n > 1) {\n        factors[n]++;\n    }\n}\n\nint main() {\n    int N;\n    cin >> N;\n\n    int m1, m2;\n    cin >> m1 >> m2;\n\n    int M = 1;\n    for (int i = 0; i < m2; ++i) {\n        M *= m1;\n    }\n\n    vector<int> Si(N);\n    for (int i = 0; i < N; ++i) {\n        cin >> Si[i];\n    }\n\n    int minTime = -1;\n\n    for (int i = 0; i < N; ++i) {\n        vector<int> factors(M + 1, 0);\n        primeFactorization(Si[i], factors);\n\n        int time = 0;\n        bool canDivide = true;\n\n        for (int j = 2; j <= M; ++j) {\n            if (factors[j] == 0) {\n                canDivide = false;\n                break;\n            }\n            time = max(time, factors[j]);\n        }\n\n        if (canDivide) {\n            if (minTime == -1 || time < minTime) {\n                minTime = time;\n            }\n        }\n    }\n\n    cout << minTime << endl;\n\n    return 0;\n}\n"
    },
    {
        "question_id": 36,
        "code_file": "\n#include <iostream>\n#include <vector>\n#include <queue>\n#include <climits>\n\nusing namespace std;\n\nconst int N = 10;\nchar grid[N][N];\nint dist[N][N];\n\nstruct Point {\n    int x, y;\n};\n\nint dx[4] = {1, -1, 0, 0};\nint dy[4] = {0, 0, 1, -1};\n\nint bfs(Point start, Point end) {\n    queue<Point> q;\n    q.push(start);\n    dist[start.x][start.y] = 1;\n\n    while (!q.empty()) {\n        Point current = q.front();\n        q.pop();\n\n        if (current.x == end.x && current.y == end.y) {\n            return dist[current.x][current.y] - 1;\n        }\n\n        for (int i = 0; i < 4; ++i) {\n            int nx = current.x + dx[i];\n            int ny = current.y + dy[i];\n\n            if (nx >= 0 && nx < N && ny >= 0 && ny < N && grid[nx][ny] != 'X' && dist[nx][ny] == 0) {\n                dist[nx][ny] = dist[current.x][current.y] + 1;\n                q.push({nx, ny});\n            }\n        }\n    }\n\n    return -1;\n}\n\nint main() {\n    Point barn, lake;\n\n    for (int i = 0; i < N; ++i) {\n        for (int j = 0; j < N; ++j) {\n            cin >> grid[i][j];\n            if (grid[i][j] == 'B') {\n                barn = {i, j};\n            } else if (grid[i][j] == 'L') {\n                lake = {i, j};\n            }\n        }\n    }\n\n    // Mark the rock as 'X' to avoid placing cows on it\n    for (int i = 0; i < N; ++i) {\n        for (int j = 0; j < N; ++j) {\n            if (grid[i][j] == 'R') {\n                grid[i][j] = 'X';\n            }\n        }\n    }\n\n    // Perform BFS from the barn and the lake\n    int barnToLake = bfs(barn, lake);\n    int lakeToBarn = bfs(lake, barn);\n\n    // The minimum number of cows is the maximum distance from either end\n    int result = max(barnToLake, lakeToBarn);\n\n    cout << result << endl;\n\n    return 0;\n}\n"
    },
    {
        "question_id": 37,
        "code_file": "\n#include <iostream>\nusing namespace std;\n\nint main() {\n    int c[3], m[3];\n    for (int i = 0; i < 3; ++i) {\n        cin >> c[i] >> m[i];\n    }\n\n    for (int i = 0; i < 100; ++i) {\n        int from = i % 3;\n        int to = (i + 1) % 3;\n        int transfer = min(m[from], c[to] - m[to]);\n        m[from] -= transfer;\n        m[to] += transfer;\n    }\n\n    for (int i = 0; i < 3; ++i) {\n        cout << m[i] << endl;\n    }\n\n    return 0;\n}\n"
    },
    {
        "question_id": 38,
        "code_file": "\n#include <iostream>\n#include <vector>\n#include <algorithm>\n\nusing namespace std;\n\nstruct Candidate {\n    int id;\n    int score;\n};\n\nbool compare(const Candidate &a, const Candidate &b) {\n    if (a.score == b.score) {\n        return a.id < b.id;\n    }\n    return a.score > b.score;\n}\n\nint main() {\n    int n, m;\n    cin >> n >> m;\n    vector<Candidate> candidates(n);\n\n    for (int i = 0; i < n; ++i) {\n        cin >> candidates[i].id >> candidates[i].score;\n    }\n\n    // Sort candidates by score in descending order, and by id in ascending order if scores are equal\n    sort(candidates.begin(), candidates.end(), compare);\n\n    // Calculate the number of candidates needed for the interview\n    int needed = m * 1.5;\n    needed = needed < n ? needed : n;\n\n    // Find the interview cut-off score\n    int cutOffScore = candidates[needed - 1].score;\n\n    // Count the number of candidates with scores >= cutOffScore\n    int count = 0;\n    for (const auto &candidate : candidates) {\n        if (candidate.score >= cutOffScore) {\n            ++count;\n        } else {\n            break;\n        }\n    }\n\n    // Output the cut-off score and the number of candidates\n    cout << cutOffScore << \" \" << count << endl;\n\n    // Output the list of candidates with scores >= cutOffScore\n    for (const auto &candidate : candidates) {\n        if (candidate.score >= cutOffScore) {\n            cout << candidate.id << \" \" << candidate.score << endl;\n        } else {\n            break;\n        }\n    }\n\n    return 0;\n}\n"
    },
    {
        "question_id": 39,
        "code_file": "\n#include <iostream>\n#include <vector>\n\nusing namespace std;\n\nint main() {\n    int n, i, j;\n    cin >> n >> i >> j;\n\n    // \u521d\u59cb\u5316\u87ba\u65cb\u77e9\u9635\n    vector<vector<int>> matrix(n, vector<int>(n, 0));\n\n    // \u5b9a\u4e49\u65b9\u5411\uff1a\u53f3\u3001\u4e0b\u3001\u5de6\u3001\u4e0a\n    vector<pair<int, int>> directions = {{0, 1}, {1, 0}, {0, -1}, {-1, 0}};\n    int currentDirection = 0; // \u5f53\u524d\u65b9\u5411\u7d22\u5f15\n\n    // \u8d77\u59cb\u4f4d\u7f6e\n    int x = 0, y = 0;\n    matrix[x][y] = 1;\n\n    // \u586b\u5145\u87ba\u65cb\u77e9\u9635\n    for (int num = 2; num <= n * n; ++num) {\n        int nextX = x + directions[currentDirection].first;\n        int nextY = y + directions[currentDirection].second;\n\n        // \u68c0\u67e5\u4e0b\u4e00\u4e2a\u4f4d\u7f6e\u662f\u5426\u5408\u6cd5\n        if (nextX < 0 || nextX >= n || nextY < 0 || nextY >= n || matrix[nextX][nextY] != 0) {\n            // \u53f3\u8f6c\n            currentDirection = (currentDirection + 1) % 4;\n            nextX = x + directions[currentDirection].first;\n            nextY = y + directions[currentDirection].second;\n        }\n\n        // \u79fb\u52a8\u5230\u4e0b\u4e00\u4e2a\u4f4d\u7f6e\n        x = nextX;\n        y = nextY;\n        matrix[x][y] = num;\n    }\n\n    // \u8f93\u51fa\u7ed3\u679c\n    cout << matrix[i - 1][j - 1] << endl;\n\n    return 0;\n}\n"
    },
    {
        "question_id": 40,
        "code_file": "\n#include <iostream>\n#include <vector>\n#include <algorithm>\n\nusing namespace std;\n\nstruct Event {\n    int time;\n    int num_buckets;\n    bool is_start;\n};\n\nbool compare_events(const Event &a, const Event &b) {\n    if (a.time == b.time) {\n        return a.is_start > b.is_start;\n    }\n    return a.time < b.time;\n}\n\nint main() {\n    int N;\n    cin >> N;\n\n    vector<Event> events;\n    for (int i = 0; i < N; ++i) {\n        int s, t, b;\n        cin >> s >> t >> b;\n        events.push_back({s, b, true});\n        events.push_back({t, b, false});\n    }\n\n    sort(events.begin(), events.end(), compare_events);\n\n    int current_buckets = 0;\n    int max_buckets = 0;\n    for (const auto &event : events) {\n        if (event.is_start) {\n            current_buckets += event.num_buckets;\n            max_buckets = max(max_buckets, current_buckets);\n        } else {\n            current_buckets -= event.num_buckets;\n        }\n    }\n\n    cout << max_buckets << endl;\n\n    return 0;\n}\n"
    },
    {
        "question_id": 41,
        "code_file": "\n#include <iostream>\n#include <vector>\n#include <algorithm>\n\nusing namespace std;\n\nint main() {\n    int N;\n    cin >> N;\n    vector<int> days(N);\n    for (int i = 0; i < N; ++i) {\n        cin >> days[i];\n    }\n\n    int min_escape = 0, max_escape = 0;\n    int last_escape_day = -1;\n\n    for (int i = 0; i < N; ++i) {\n        if (days[i] == -1) {\n            if (last_escape_day == -1) {\n                // \u5982\u679c\u4e4b\u524d\u6ca1\u6709\u51fa\u9003\u8bb0\u5f55\uff0c\u5219\u7b2c1\u5929\u5fc5\u7136\u6709\u51fa\u9003\n                last_escape_day = 0;\n                min_escape++;\n                max_escape++;\n            } else {\n                // \u5982\u679c\u4e4b\u524d\u6709\u51fa\u9003\u8bb0\u5f55\uff0c\u5219\u7b2ci\u5929\u5fc5\u7136\u6709\u51fa\u9003\n                last_escape_day = i;\n                min_escape++;\n                max_escape++;\n            }\n        } else {\n            if (last_escape_day == -1) {\n                // \u5982\u679c\u4e4b\u524d\u6ca1\u6709\u51fa\u9003\u8bb0\u5f55\uff0c\u5219\u7b2c1\u5929\u5fc5\u7136\u6709\u51fa\u9003\n                last_escape_day = 0;\n                min_escape++;\n                max_escape++;\n            } else {\n                // \u5982\u679c\u4e4b\u524d\u6709\u51fa\u9003\u8bb0\u5f55\uff0c\u5219\u8ba1\u7b97\u7b2ci\u5929\u4e0e\u4e0a\u6b21\u51fa\u9003\u7684\u5929\u6570\u5dee\n                int days_since_last_escape = i - last_escape_day;\n                if (days_since_last_escape == days[i]) {\n                    // \u5982\u679c\u5929\u6570\u5dee\u4e0e\u8bb0\u5f55\u4e00\u81f4\uff0c\u5219\u7b2ci\u5929\u5fc5\u7136\u6709\u51fa\u9003\n                    last_escape_day = i;\n                    min_escape++;\n                    max_escape++;\n                } else if (days_since_last_escape > days[i]) {\n                    // \u5982\u679c\u5929\u6570\u5dee\u5927\u4e8e\u8bb0\u5f55\uff0c\u5219\u7b2ci\u5929\u5fc5\u7136\u6709\u51fa\u9003\n                    last_escape_day = i;\n                    min_escape++;\n                    max_escape++;\n                } else {\n                    // \u5982\u679c\u5929\u6570\u5dee\u5c0f\u4e8e\u8bb0\u5f55\uff0c\u5219\u7b2ci\u5929\u6ca1\u6709\u51fa\u9003\n                    min_escape += days[i] - days_since_last_escape;\n                    max_escape += days[i] - days_since_last_escape;\n                }\n            }\n        }\n    }\n\n    cout << min_escape << \" \" << max_escape << endl;\n\n    return 0;\n}\n"
    },
    {
        "question_id": 42,
        "code_file": "\n#include <iostream>\n#include <algorithm>\n#include <numeric> // for std::gcd\n\nusing namespace std;\n\nint main() {\n    int A, B, L;\n    cin >> A >> B >> L;\n\n    // \u627e\u5230 A \u548c B \u7684\u6700\u5927\u516c\u7ea6\u6570\n    int gcd = std::gcd(A, B);\n\n    // \u5316\u7b80 A \u548c B\n    A /= gcd;\n    B /= gcd;\n\n    // \u521d\u59cb\u5316\u6700\u5c0f\u5dee\u503c\u548c\u6700\u4f18\u89e3\n    double min_diff = 1e9;\n    int best_A = 0, best_B = 0;\n\n    // \u679a\u4e3e\u6240\u6709\u53ef\u80fd\u7684 A' \u548c B'\n    for (int a = 1; a <= L; ++a) {\n        for (int b = 1; b <= L; ++b) {\n            if (std::gcd(a, b) == 1) { // \u786e\u4fdd A' \u548c B' \u4e92\u8d28\n                double ratio = (double)a / b;\n                double current_diff = ratio - (double)A / B;\n                if (current_diff >= 0 && current_diff < min_diff) {\n                    min_diff = current_diff;\n                    best_A = a;\n                    best_B = b;\n                }\n            }\n        }\n    }\n\n    // \u8f93\u51fa\u7ed3\u679c\n    cout << best_A << \" \" << best_B << endl;\n\n    return 0;\n}\n"
    },
    {
        "question_id": 43,
        "code_file": "\n#include <iostream>\n#include <vector>\n#include <unordered_set>\n\nusing namespace std;\n\nint main() {\n    vector<int> b1(10), b2(10);\n    for (int i = 0; i < 10; ++i) {\n        cin >> b1[i];\n    }\n    for (int i = 0; i < 10; ++i) {\n        cin >> b2[i];\n    }\n\n    unordered_set<int> milk_amounts;\n    milk_amounts.insert(1000); // \u521d\u59cb\u72b6\u6001\n\n    for (int i = 0; i < 10; ++i) {\n        for (int j = 0; j < 10; ++j) {\n            int new_amount = 1000 + b1[i] - b2[j];\n            milk_amounts.insert(new_amount);\n            new_amount = 1000 + b2[j] - b1[i];\n            milk_amounts.insert(new_amount);\n        }\n    }\n\n    cout << milk_amounts.size() << endl;\n\n    return 0;\n}\n"
    },
    {
        "question_id": 44,
        "code_file": "\n#include <iostream>\n#include <vector>\n#include <string>\n#include <set>\n#include <algorithm>\n\nusing namespace std;\n\n// Function to check if a given set of sub-populations can form a proper evolutionary tree\nbool canFormProperTree(const vector<vector<string>>& subpopulations) {\n    int n = subpopulations.size();\n    vector<set<string>> features(n);\n\n    // Extract features for each sub-population\n    for (int i = 0; i < n; ++i) {\n        for (int j = 1; j < subpopulations[i].size(); ++j) {\n            features[i].insert(subpopulations[i][j]);\n        }\n    }\n\n    // Check if each feature appears in exactly one sub-population\n    for (int i = 0; i < n; ++i) {\n        for (int j = 0; j < n; ++j) {\n            if (i != j) {\n                for (const string& feature : features[i]) {\n                    if (features[j].find(feature) != features[j].end()) {\n                        return false; // Feature appears in more than one sub-population\n                    }\n                }\n            }\n        }\n    }\n\n    return true;\n}\n\nint main() {\n    int n;\n    cin >> n;\n    vector<vector<string>> subpopulations(n);\n\n    // Read input for each sub-population\n    for (int i = 0; i < n; ++i) {\n        int k;\n        cin >> k;\n        subpopulations[i].push_back(to_string(k)); // Store the count of features\n        for (int j = 0; j < k; ++j) {\n            string feature;\n            cin >> feature;\n            subpopulations[i].push_back(feature);\n        }\n    }\n\n    // Determine if a proper evolutionary tree can be formed\n    if (canFormProperTree(subpopulations)) {\n        cout << \"yes\" << endl;\n    } else {\n        cout << \"no\" << endl;\n    }\n\n    return 0;\n}\n"
    },
    {
        "question_id": 45,
        "code_file": "\n#include <iostream>\n#include <string>\n#include <algorithm>\n\nusing namespace std;\n\n// \u5224\u65ad\u4e00\u4e2a\u5e74\u4efd\u662f\u5426\u662f\u95f0\u5e74\nbool isLeapYear(int year) {\n    return (year % 4 == 0 && year % 100 != 0) || (year % 400 == 0);\n}\n\n// \u5224\u65ad\u4e00\u4e2a\u65e5\u671f\u662f\u5426\u662f\u56de\u6587\u65e5\u671f\nbool isPalindromeDate(int date) {\n    string dateStr = to_string(date);\n    string reversedDateStr = dateStr;\n    reverse(reversedDateStr.begin(), reversedDateStr.end());\n    return dateStr == reversedDateStr;\n}\n\n// \u83b7\u53d6\u67d0\u5e74\u67d0\u6708\u7684\u5929\u6570\nint getDaysInMonth(int year, int month) {\n    if (month == 2) {\n        return isLeapYear(year) ? 29 : 28;\n    } else if (month == 4 || month == 6 || month == 9 || month == 11) {\n        return 30;\n    } else {\n        return 31;\n    }\n}\n\nint main() {\n    int startDate, endDate;\n    cin >> startDate >> endDate;\n\n    int count = 0;\n    for (int date = startDate; date <= endDate; ++date) {\n        int year = date / 10000;\n        int month = (date / 100) % 100;\n        int day = date % 100;\n\n        // \u68c0\u67e5\u65e5\u671f\u7684\u5408\u6cd5\u6027\n        if (month > 12 || day > getDaysInMonth(year, month)) {\n            continue;\n        }\n\n        // \u68c0\u67e5\u65e5\u671f\u662f\u5426\u662f\u56de\u6587\n        if (isPalindromeDate(date)) {\n            ++count;\n        }\n    }\n\n    cout << count << endl;\n    return 0;\n}\n"
    },
    {
        "question_id": 46,
        "code_file": "\n#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <cmath>\n\nusing namespace std;\n\n// \u8ba1\u7b97\u4e24\u70b9\u4e4b\u95f4\u7684\u8ddd\u79bb\u5e73\u65b9\nint distanceSquared(int x1, int y1, int x2, int y2) {\n    return (x1 - x2) * (x1 - x2) + (y1 - y2) * (y1 - y2);\n}\n\nint main() {\n    int x1, y1, x2, y2, N;\n    cin >> x1 >> y1 >> x2 >> y2;\n    cin >> N;\n\n    vector<int> distances1(N), distances2(N);\n\n    // \u8ba1\u7b97\u6bcf\u4e2a\u5bfc\u5f39\u5230\u4e24\u4e2a\u62e6\u622a\u7cfb\u7edf\u7684\u8ddd\u79bb\u5e73\u65b9\n    for (int i = 0; i < N; ++i) {\n        int xi, yi;\n        cin >> xi >> yi;\n        distances1[i] = distanceSquared(x1, y1, xi, yi);\n        distances2[i] = distanceSquared(x2, y2, xi, yi);\n    }\n\n    // \u5bf9\u8ddd\u79bb\u8fdb\u884c\u6392\u5e8f\n    sort(distances1.begin(), distances1.end());\n    sort(distances2.begin(), distances2.end());\n\n    // \u8ba1\u7b97\u6700\u5c0f\u4f7f\u7528\u4ee3\u4ef7\n    int minCost = INT_MAX;\n    for (int i = 0; i < N; ++i) {\n        int cost = distances1[i] + distances2[N - 1 - i];\n        if (cost < minCost) {\n            minCost = cost;\n        }\n    }\n\n    cout << minCost << endl;\n\n    return 0;\n}\n"
    },
    {
        "question_id": 47,
        "code_file": "\n#include <iostream>\n#include <vector>\n#include <algorithm>\n\nint main() {\n    int n;\n    std::cin >> n;\n    std::vector<int> numbers(n);\n\n    // \u8bfb\u53d6\u8f93\u5165\u7684\u6b63\u6574\u6570\n    for (int i = 0; i < n; ++i) {\n        std::cin >> numbers[i];\n    }\n\n    // \u5bf9\u6570\u7ec4\u8fdb\u884c\u6392\u5e8f\uff0c\u65b9\u4fbf\u540e\u7eed\u67e5\u627e\n    std::sort(numbers.begin(), numbers.end());\n\n    int count = 0;\n\n    // \u904d\u5386\u6570\u7ec4\u4e2d\u7684\u6bcf\u4e00\u4e2a\u6570\uff0c\u5c1d\u8bd5\u627e\u5230\u4e24\u4e2a\u4e0d\u540c\u7684\u6570\u4e4b\u548c\u7b49\u4e8e\u8be5\u6570\n    for (int i = 0; i < n; ++i) {\n        for (int j = i + 1; j < n; ++j) {\n            // \u4f7f\u7528\u4e8c\u5206\u67e5\u627e\u5224\u65ad\u662f\u5426\u5b58\u5728\u4e24\u4e2a\u6570\u4e4b\u548c\u7b49\u4e8e\u5f53\u524d\u6570\n            if (std::binary_search(numbers.begin(), numbers.end(), numbers[i] + numbers[j])) {\n                count++;\n                break; // \u627e\u5230\u4e00\u4e2a\u7b26\u5408\u6761\u4ef6\u7684\u6570\u5bf9\u540e\uff0c\u8df3\u51fa\u5185\u5c42\u5faa\u73af\n            }\n        }\n    }\n\n    // \u8f93\u51fa\u7ed3\u679c\n    std::cout << count << std::endl;\n\n    return 0;\n}\n"
    },
    {
        "question_id": 48,
        "code_file": "\n#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <climits>\n\nusing namespace std;\n\nint main() {\n    int n, m, p;\n    cin >> n >> m >> p;\n\n    vector<vector<int>> coins(n, vector<int>(m));\n    for (int i = 0; i < n; ++i) {\n        for (int j = 0; j < m; ++j) {\n            cin >> coins[i][j];\n        }\n    }\n\n    vector<int> cost(n);\n    for (int i = 0; i < n; ++i) {\n        cin >> cost[i];\n    }\n\n    // dp[i][j] \u8868\u793a\u7b2c i \u4e2a\u65f6\u95f4\u70b9\u5728 j \u4e2a\u5de5\u5382\u8d2d\u4e70\u673a\u5668\u4eba\u80fd\u83b7\u5f97\u7684\u6700\u5927\u91d1\u5e01\u6570\n    vector<vector<int>> dp(m + 1, vector<int>(n, INT_MIN));\n    for (int i = 0; i < n; ++i) {\n        dp[1][i] = -cost[i];\n    }\n\n    for (int t = 1; t <= m; ++t) {\n        for (int i = 0; i < n; ++i) {\n            for (int k = 1; k <= p && t - k >= 0; ++k) {\n                int prev_factory = (i - k + n) % n;\n                dp[t][i] = max(dp[t][i], dp[t - k][prev_factory] + coins[i][(t - k) % m]);\n            }\n        }\n    }\n\n    int max_coins = INT_MIN;\n    for (int i = 0; i < n; ++i) {\n        max_coins = max(max_coins, dp[m][i]);\n    }\n\n    cout << max_coins << endl;\n\n    return 0;\n}\n"
    },
    {
        "question_id": 49,
        "code_file": "\n#include <iostream>\n#include <vector>\n#include <cstring>\n\nusing namespace std;\n\nconst int MOD = 1e9 + 7;\nconst int MAXN = 2000;\n\nint N;\nvector<string> field;\nvector<vector<int>> dp;\nvector<vector<int>> prefixSum;\n\nvoid computePrefixSum() {\n    prefixSum = vector<vector<int>>(N + 1, vector<int>(N + 1, 0));\n    for (int i = 1; i <= N; ++i) {\n        for (int j = 1; j <= N; ++j) {\n            prefixSum[i][j] = (field[i-1][j-1] == 'W') ? 0 : (prefixSum[i-1][j] + prefixSum[i][j-1] - prefixSum[i-1][j-1] + 1);\n        }\n    }\n}\n\nint countWays(int i, int j) {\n    if (i < 1 || j < 1 || i > N || j > N) return 0;\n    if (dp[i][j] != -1) return dp[i][j];\n    int total = (prefixSum[N][N] - prefixSum[i-1][N] - prefixSum[N][j-1] + prefixSum[i-1][j-1]);\n    int sweetCorn = (prefixSum[i-1][j-1] - prefixSum[i-1][0] - prefixSum[0][j-1] + prefixSum[0][0]);\n    int alfalfa = (prefixSum[N][N] - prefixSum[0][j-1] - prefixSum[i-1][N] + prefixSum[0][0]);\n    dp[i][j] = (alfalfa - sweetCorn + MOD) % MOD;\n    return dp[i][j];\n}\n\nint main() {\n    ios::sync_with_stdio(false);\n    cin.tie(0);\n\n    cin >> N;\n    field.resize(N);\n    dp = vector<vector<int>>(N + 1, vector<int>(N + 1, -1));\n\n    for (int i = 0; i < N; ++i) {\n        cin >> field[i];\n    }\n\n    computePrefixSum();\n\n    int result = 0;\n    for (int i = 1; i <= N; ++i) {\n        for (int j = 1; j <= N; ++j) {\n            result = (result + countWays(i, j)) % MOD;\n        }\n    }\n\n    cout << result << endl;\n\n    return 0;\n}\n"
    },
    {
        "question_id": 50,
        "code_file": "\n#include <iostream>\n#include <vector>\n\nconst int MOD = 1000007;\n\nint main() {\n    int n, m;\n    std::cin >> n >> m;\n    std::vector<int> a(n + 1);\n    for (int i = 1; i <= n; ++i) {\n        std::cin >> a[i];\n    }\n\n    // dp[i][j] \u8868\u793a\u524d i \u79cd\u82b1\u6446 j \u76c6\u82b1\u7684\u65b9\u6848\u6570\n    std::vector<std::vector<int>> dp(n + 1, std::vector<int>(m + 1, 0));\n    dp[0][0] = 1; // \u521d\u59cb\u72b6\u6001\uff0c0 \u79cd\u82b1\u6446 0 \u76c6\u82b1\u7684\u65b9\u6848\u6570\u4e3a 1\n\n    for (int i = 1; i <= n; ++i) {\n        for (int j = 0; j <= m; ++j) {\n            for (int k = 0; k <= a[i]; ++k) {\n                if (j >= k) {\n                    dp[i][j] = (dp[i][j] + dp[i - 1][j - k]) % MOD;\n                }\n            }\n        }\n    }\n\n    std::cout << dp[n][m] << std::endl;\n    return 0;\n}\n"
    },
    {
        "question_id": 51,
        "code_file": "\n#include <iostream>\n#include <vector>\n#include <algorithm>\n\nusing namespace std;\n\nint main() {\n    int l, m;\n    cin >> l >> m;\n\n    // \u521d\u59cb\u5316\u4e00\u4e2a\u5e03\u5c14\u6570\u7ec4\u8868\u793a\u6bcf\u68f5\u6811\u662f\u5426\u5b58\u5728\uff0c\u521d\u59cb\u503c\u4e3atrue\n    vector<bool> trees(l + 1, true);\n\n    // \u8bfb\u53d6\u6bcf\u4e2a\u533a\u57df\u7684\u8d77\u59cb\u70b9\u548c\u7ec8\u6b62\u70b9\uff0c\u5e76\u5c06\u8fd9\u4e9b\u533a\u57df\u5185\u7684\u6811\u6807\u8bb0\u4e3afalse\n    for (int i = 0; i < m; ++i) {\n        int u, v;\n        cin >> u >> v;\n        fill(trees.begin() + u, trees.begin() + v + 1, false);\n    }\n\n    // \u7edf\u8ba1\u5269\u4f59\u7684\u6811\u7684\u6570\u91cf\n    int remaining_trees = count(trees.begin(), trees.begin() + l + 1, true);\n\n    // \u8f93\u51fa\u7ed3\u679c\n    cout << remaining_trees << endl;\n\n    return 0;\n}\n"
    },
    {
        "question_id": 52,
        "code_file": "\n#include <bits/stdc++.h>\nusing namespace std;\ntypedef unsigned long long ull;\ntypedef __uint128_t L;\nstruct FastMod {\n    ull b, m;\n    FastMod(ull b) : b(b), m(ull((L(1) << 64) / b)) {}\n    ull reduce(ull a) {\n        ull q = (ull)((L(m) * a) >> 64);\n        ull r = a - q * b; // can be proven that 0<= r < 2*b\n        return r >= b ? r - b : r;\n    }\n};\nFastMod F(2);\nint main() {\n    int M = 1000000007; F = FastMod(M);\n    ull x = 10ULL*M+3;\n    cout << x << \" \" << F.reduce(x) << \"\\n\"; // 10000000073 3\n}\n"
    },
    {
        "question_id": 53,
        "code_file": "\n#include <iostream>\n#include <vector>\n#include <algorithm>\n\nint main() {\n    int N;\n    std::cin >> N;\n\n    std::vector<int> numbers(N);\n    for (int i = 0; i < N; ++i) {\n        std::cin >> numbers[i];\n    }\n\n    // \u4f7f\u7528 std::sort \u8fdb\u884c\u6392\u5e8f\n    std::sort(numbers.begin(), numbers.end());\n\n    // \u53bb\u91cd\n    numbers.erase(std::unique(numbers.begin(), numbers.end()), numbers.end());\n\n    // \u8f93\u51fa\u53bb\u91cd\u540e\u7684\u5143\u7d20\u4e2a\u6570\n    std::cout << numbers.size() << std::endl;\n\n    // \u8f93\u51fa\u53bb\u91cd\u5e76\u6392\u5e8f\u540e\u7684\u5143\u7d20\n    for (int i = 0; i < numbers.size(); ++i) {\n        std::cout << numbers[i] << \" \";\n    }\n    std::cout << std::endl;\n\n    return 0;\n}\n"
    },
    {
        "question_id": 54,
        "code_file": "\n#include <iostream>\n#include <vector>\n#include <algorithm>\n\nconst int MOD = 1000000007;\n\nusing namespace std;\n\nvector<int> parent, size, dp;\n\nint find_set(int v) {\n    if (v == parent[v])\n        return v;\n    return parent[v] = find_set(parent[v]);\n}\n\nvoid union_sets(int a, int b) {\n    a = find_set(a);\n    b = find_set(b);\n    if (a != b) {\n        if (size[a] < size[b])\n            swap(a, b);\n        parent[b] = a;\n        size[a] += size[b];\n    }\n}\n\nint main() {\n    int n;\n    cin >> n;\n    vector<vector<int>> graph(n + 1);\n    for (int i = 0; i < n - 1; ++i) {\n        int a, b;\n        cin >> a >> b;\n        graph[a].push_back(b);\n        graph[b].push_back(a);\n    }\n\n    parent.resize(n + 1);\n    size.resize(n + 1, 1);\n    dp.resize(n + 1, 1);\n\n    for (int i = 1; i <= n; ++i)\n        parent[i] = i;\n\n    for (int i = 1; i <= n; ++i) {\n        for (int v : graph[i]) {\n            union_sets(i, v);\n        }\n    }\n\n    for (int i = 1; i <= n; ++i) {\n        int root = find_set(i);\n        dp[root] = (dp[root] * (size[root] - 1)) % MOD;\n    }\n\n    for (int i = 1; i <= n; ++i) {\n        int root = find_set(i);\n        dp[root] = (dp[root] * dp[root]) % MOD;\n    }\n\n    for (int i = 1; i <= n; ++i) {\n        cout << dp[find_set(i)] << endl;\n    }\n\n    return 0;\n}\n"
    },
    {
        "question_id": 55,
        "code_file": "\n#include <iostream>\n#include <vector>\n#include <algorithm>\n\nusing namespace std;\n\nint main() {\n    int T, M;\n    cin >> T >> M;\n\n    vector<int> time(M), value(M);\n    for (int i = 0; i < M; ++i) {\n        cin >> time[i] >> value[i];\n    }\n\n    // \u52a8\u6001\u89c4\u5212\u6570\u7ec4\uff0cdp[i] \u8868\u793a\u5728\u65f6\u95f4 i \u5185\u53ef\u4ee5\u83b7\u5f97\u7684\u6700\u5927\u4ef7\u503c\n    vector<int> dp(T + 1, 0);\n\n    // \u904d\u5386\u6bcf\u4e00\u4e2a\u8349\u836f\n    for (int i = 0; i < M; ++i) {\n        // \u4ece\u540e\u5411\u524d\u904d\u5386\uff0c\u907f\u514d\u91cd\u590d\u4f7f\u7528\u540c\u4e00\u8349\u836f\n        for (int j = T; j >= time[i]; --j) {\n            dp[j] = max(dp[j], dp[j - time[i]] + value[i]);\n        }\n    }\n\n    // \u8f93\u51fa\u5728\u89c4\u5b9a\u65f6\u95f4\u5185\u53ef\u4ee5\u83b7\u5f97\u7684\u6700\u5927\u4ef7\u503c\n    cout << dp[T] << endl;\n\n    return 0;\n}\n"
    },
    {
        "question_id": 56,
        "code_file": "\n#include <iostream>\n#include <vector>\n#include <algorithm>\n\nusing namespace std;\n\ntypedef long long ll;\n\n// Function to count inversions using Binary Indexed Tree (BIT)\nll countInversions(const vector<int>& arr) {\n    int n = arr.size();\n    vector<int> temp(n + 1, 0);\n    ll inversions = 0;\n\n    for (int i = n - 1; i >= 0; --i) {\n        inversions += temp[arr[i]];\n        for (int j = arr[i]; j <= n; j += j & -j) {\n            temp[j]++;\n        }\n    }\n\n    return inversions;\n}\n\nint main() {\n    int n;\n    cin >> n;\n    vector<int> arr(n);\n\n    for (int i = 0; i < n; ++i) {\n        cin >> arr[i];\n    }\n\n    vector<ll> badness(n, 0);\n\n    // Calculate initial inversions\n    badness[0] = countInversions(arr);\n\n    // Calculate inversions for each j from 1 to N-1\n    for (int j = 1; j < n; ++j) {\n        vector<int> modifiedArr(arr);\n        for (int i = 0; i < n; ++i) {\n            if (arr[i] > j) {\n                modifiedArr[i] = j;\n            }\n        }\n        badness[j] = countInversions(modifiedArr);\n    }\n\n    // Output the results\n    for (int j = 0; j < n; ++j) {\n        cout << badness[j] << endl;\n    }\n\n    return 0;\n}\n"
    },
    {
        "question_id": 57,
        "code_file": "\n#include <iostream>\n#include <string>\n#include <stack>\n\nusing namespace std;\n\n// \u8ba1\u7b97\u8868\u8fbe\u5f0f\u7684\u503c\nint evaluateExpression(const string& expression) {\n    stack<int> numbers;\n    char op = '+';\n    int num = 0;\n\n    for (char c : expression) {\n        if (isdigit(c)) {\n            num = num * 10 + (c - '0');\n        }\n\n        if (!isdigit(c) || expression.length() - 1 == &c - &expression[0]) {\n            if (op == '+') {\n                numbers.push(num);\n            } else if (op == '*') {\n                numbers.top() = (numbers.top() * num) % 10000;\n            }\n            op = c;\n            num = 0;\n        }\n    }\n\n    int result = 0;\n    while (!numbers.empty()) {\n        result = (result + numbers.top()) % 10000;\n        numbers.pop();\n    }\n\n    return result;\n}\n\nint main() {\n    string expression;\n    cin >> expression;\n    cout << evaluateExpression(expression) << endl;\n    return 0;\n}\n"
    },
    {
        "question_id": 58,
        "code_file": "\n#include <iostream>\n#include <vector>\n#include <algorithm>\n\nusing namespace std;\n\nint main() {\n    int N, M;\n    cin >> N >> M;\n    \n    vector<int> v(M + 1), p(M + 1);\n    for (int i = 1; i <= M; ++i) {\n        cin >> v[i] >> p[i];\n    }\n    \n    // dp[i] \u8868\u793a\u94b1\u6570\u4e0d\u8d85\u8fc7 i \u65f6\u7684\u6700\u5927\u4ef7\u503c\n    vector<int> dp(N + 1, 0);\n    \n    for (int i = 1; i <= M; ++i) {\n        for (int j = N; j >= v[i]; --j) {\n            dp[j] = max(dp[j], dp[j - v[i]] + v[i] * p[i]);\n        }\n    }\n    \n    cout << dp[N] << endl;\n    \n    return 0;\n}\n"
    },
    {
        "question_id": 59,
        "code_file": "\n#include <iostream>\n#include <vector>\n#include <algorithm>\n\nusing namespace std;\n\n// Function to find the lexicographically smallest color assignment\nvector<int> smallestColorAssignment(int N, int M, const vector<pair<int, int>>& pairs) {\n    vector<vector<int>> adj(N + 1); // Adjacency list for the graph\n    vector<int> color(N + 1, 0); // Color array to store the color of each cow\n\n    // Build the graph\n    for (const auto& p : pairs) {\n        adj[p.first].push_back(p.second);\n    }\n\n    // Sort the adjacency lists to ensure lexicographical order\n    for (int i = 1; i <= N; ++i) {\n        sort(adj[i].begin(), adj[i].end());\n    }\n\n    // Assign colors using a DFS approach\n    function<void(int)> dfs = [&](int u) {\n        for (int v : adj[u]) {\n            if (color[v] == 0) {\n                color[v] = color[u] + 1;\n                dfs(v);\n            }\n        }\n    };\n\n    // Perform DFS from each uncolored node\n    for (int i = 1; i <= N; ++i) {\n        if (color[i] == 0) {\n            color[i] = 1;\n            dfs(i);\n        }\n    }\n\n    return color;\n}\n\nint main() {\n    int N, M;\n    cin >> N >> M;\n\n    vector<pair<int, int>> pairs(M);\n    for (int i = 0; i < M; ++i) {\n        cin >> pairs[i].first >> pairs[i].second;\n    }\n\n    vector<int> result = smallestColorAssignment(N, M, pairs);\n\n    // Output the result\n    for (int i = 1; i <= N; ++i) {\n        cout << result[i] << endl;\n    }\n\n    return 0;\n}\n"
    },
    {
        "question_id": 60,
        "code_file": "\n#include <iostream>\n#include <string>\nusing namespace std;\n\n// \u51fd\u6570\uff1a\u751f\u6210\u4e0b\u4e00\u4e2a Jam \u6570\u5b57\nstring nextJamNumber(const string &current, int s, int t, int w) {\n    string next = current;\n    int pos = w - 1;\n\n    // \u4ece\u53f3\u5411\u5de6\u627e\u5230\u7b2c\u4e00\u4e2a\u53ef\u4ee5\u589e\u52a0\u7684\u5b57\u7b26\u4f4d\u7f6e\n    while (pos >= 0 && next[pos] == char(t + 'a' - 1)) {\n        pos--;\n    }\n\n    // \u5982\u679c\u627e\u5230\u4e86\u53ef\u4ee5\u589e\u52a0\u7684\u5b57\u7b26\u4f4d\u7f6e\n    if (pos >= 0) {\n        next[pos] = char(next[pos] + 1);\n        // \u5c06 pos \u540e\u9762\u7684\u5b57\u7b26\u91cd\u7f6e\u4e3a\u6700\u5c0f\u503c\n        for (int i = pos + 1; i < w; i++) {\n            next[i] = char(s + 'a' - 1);\n        }\n    }\n\n    return next;\n}\n\nint main() {\n    int s, t, w;\n    string current;\n\n    // \u8bfb\u53d6\u8f93\u5165\n    cin >> s >> t >> w;\n    cin >> current;\n\n    // \u751f\u6210\u5e76\u8f93\u51fa\u63a5\u4e0b\u6765\u7684 5 \u4e2a Jam \u6570\u5b57\n    for (int i = 0; i < 5; i++) {\n        string next = nextJamNumber(current, s, t, w);\n        if (next.empty()) {\n            break;\n        }\n        cout << next << endl;\n        current = next;\n    }\n\n    return 0;\n}\n"
    },
    {
        "question_id": 61,
        "code_file": "\n#include <iostream>\n#include <string>\n\nint main() {\n    std::string title;\n    std::getline(std::cin, title); // \u8bfb\u53d6\u6574\u884c\u8f93\u5165\n\n    int count = 0; // \u521d\u59cb\u5316\u8ba1\u6570\u5668\n\n    // \u904d\u5386\u5b57\u7b26\u4e32\u4e2d\u7684\u6bcf\u4e00\u4e2a\u5b57\u7b26\n    for (char c : title) {\n        // \u5224\u65ad\u5b57\u7b26\u662f\u5426\u4e3a\u975e\u7a7a\u683c\u548c\u975e\u6362\u884c\u7b26\n        if (c != ' ' && c != '\\n') {\n            count++; // \u5982\u679c\u662f\uff0c\u8ba1\u6570\u5668\u52a0\u4e00\n        }\n    }\n\n    // \u8f93\u51fa\u7ed3\u679c\n    std::cout << count << std::endl;\n\n    return 0;\n}\n"
    },
    {
        "question_id": 62,
        "code_file": "\n#include <iostream>\n#include <vector>\n#include <algorithm>\n\nusing namespace std;\n\nstruct Interval {\n    long long a, b;\n};\n\nbool compareIntervals(const Interval &i1, const Interval &i2) {\n    return i1.a < i2.a;\n}\n\nint main() {\n    int N, M;\n    cin >> N >> M;\n\n    vector<Interval> intervals(M);\n    for (int i = 0; i < M; ++i) {\n        cin >> intervals[i].a >> intervals[i].b;\n    }\n\n    sort(intervals.begin(), intervals.end(), compareIntervals);\n\n    vector<long long> grass_positions;\n    for (const auto &interval : intervals) {\n        grass_positions.push_back(interval.a);\n        if (interval.a != interval.b) {\n            grass_positions.push_back(interval.b);\n        }\n    }\n\n    sort(grass_positions.begin(), grass_positions.end());\n\n    int num_grass_positions = grass_positions.size();\n    if (num_grass_positions < N) {\n        cout << \"0\" << endl;\n        return 0;\n    }\n\n    long long max_distance = 0;\n    for (int i = 1; i <= num_grass_positions - N; ++i) {\n        long long distance = grass_positions[i + N - 1] - grass_positions[i];\n        if (distance > max_distance) {\n            max_distance = distance;\n        }\n    }\n\n    cout << max_distance / (N - 1) << endl;\n\n    return 0;\n}\n"
    },
    {
        "question_id": 63,
        "code_file": "\n#include <iostream>\n#include <vector>\n\nusing namespace std;\n\n// \u8ba1\u7b97\u7b2c N \u9879\u7684\u503c\nint calculateNthTerm(int k, int N) {\n    vector<int> sequence;\n    sequence.push_back(1); // \u521d\u59cb\u9879 1\n\n    // \u751f\u6210\u5e8f\u5217\n    for (int i = 1; i < N; ++i) {\n        int nextTerm = 0;\n        for (int j = 0; j < sequence.size(); ++j) {\n            nextTerm += sequence[j] * k;\n            sequence.push_back(nextTerm);\n        }\n    }\n\n    return sequence[N - 1];\n}\n\nint main() {\n    int k, N;\n    cin >> k >> N;\n\n    int result = calculateNthTerm(k, N);\n    cout << result << endl;\n\n    return 0;\n}\n"
    },
    {
        "question_id": 64,
        "code_file": "\n#include <iostream>\n#include <vector>\n#include <unordered_map>\n\nint main() {\n    int N, M;\n    std::cin >> N >> M;\n\n    std::vector<int> favorite(N), second_favorite(N);\n    for (int i = 0; i < N; ++i) {\n        std::cin >> favorite[i] >> second_favorite[i];\n    }\n\n    std::vector<int> result(N);\n    std::unordered_map<int, int> available;\n\n    for (int i = 0; i < N; ++i) {\n        available[favorite[i]]++;\n        available[second_favorite[i]]++;\n\n        if (available[favorite[i]] > 0) {\n            available[favorite[i]]--;\n            result[i] = i + 1;\n        } else if (available[second_favorite[i]] > 0) {\n            available[second_favorite[i]]--;\n            result[i] = i + 1;\n        } else {\n            result[i] = result[i - 1];\n        }\n    }\n\n    for (int i = 0; i < N; ++i) {\n        std::cout << result[i] << std::endl;\n    }\n\n    return 0;\n}\n"
    },
    {
        "question_id": 65,
        "code_file": "\n#include <iostream>\n#include <vector>\n#include <algorithm>\n\nusing namespace std;\n\nstruct Student {\n    int id;\n    int chinese;\n    int math;\n    int english;\n    int total;\n\n    // Constructor to initialize a student with given scores\n    Student(int id, int chinese, int math, int english) : id(id), chinese(chinese), math(math), english(english) {\n        total = chinese + math + english;\n    }\n\n    // Comparator for sorting students based on the problem statement\n    bool operator<(const Student& other) const {\n        if (total != other.total) {\n            return total > other.total; // Higher total score first\n        } else if (chinese != other.chinese) {\n            return chinese > other.chinese; // Higher Chinese score first if total scores are equal\n        } else {\n            return id < other.id; // Lower student ID if total and Chinese scores are equal\n        }\n    }\n};\n\nint main() {\n    int n;\n    cin >> n;\n\n    vector<Student> students(n);\n\n    // Read student data\n    for (int i = 0; i < n; ++i) {\n        int chinese, math, english;\n        cin >> chinese >> math >> english;\n        students[i] = Student(i + 1, chinese, math, english);\n    }\n\n    // Sort students based on the custom comparator\n    sort(students.begin(), students.end());\n\n    // Output the top 5 students\n    for (int i = 0; i < 5; ++i) {\n        cout << students[i].id << \" \" << students[i].total << endl;\n    }\n\n    return 0;\n}\n"
    },
    {
        "question_id": 66,
        "code_file": "\n#include <iostream>\n#include <vector>\n#include <algorithm>\n\nusing namespace std;\n\nstruct MooParticle {\n    int x, y;\n};\n\nbool compare(const MooParticle &a, const MooParticle &b) {\n    if (a.x != b.x) return a.x < b.x;\n    return a.y < b.y;\n}\n\nint main() {\n    int N;\n    cin >> N;\n    vector<MooParticle> particles(N);\n\n    for (int i = 0; i < N; ++i) {\n        cin >> particles[i].x >> particles[i].y;\n    }\n\n    sort(particles.begin(), particles.end(), compare);\n\n    int remaining = 1;\n    int max_y = particles[0].y;\n\n    for (int i = 1; i < N; ++i) {\n        if (particles[i].y > max_y) {\n            remaining++;\n            max_y = particles[i].y;\n        }\n    }\n\n    cout << remaining << endl;\n\n    return 0;\n}\n"
    },
    {
        "question_id": 67,
        "code_file": "\n#include <iostream>\n#include <vector>\n#include <algorithm>\n\nint main() {\n    int w, n;\n    std::cin >> w >> n;\n    std::vector<int> prices(n);\n    \n    for (int i = 0; i < n; ++i) {\n        std::cin >> prices[i];\n    }\n    \n    // \u5bf9\u7eaa\u5ff5\u54c1\u4ef7\u683c\u8fdb\u884c\u6392\u5e8f\n    std::sort(prices.begin(), prices.end());\n    \n    int left = 0, right = n - 1;\n    int groups = 0;\n    \n    // \u4f7f\u7528\u53cc\u6307\u9488\u6cd5\u8fdb\u884c\u5206\u7ec4\n    while (left <= right) {\n        if (prices[left] + prices[right] <= w) {\n            // \u5982\u679c\u5f53\u524d\u6700\u4fbf\u5b9c\u548c\u6700\u8d35\u7684\u7eaa\u5ff5\u54c1\u53ef\u4ee5\u7ec4\u6210\u4e00\u7ec4\n            left++;\n        }\n        // \u65e0\u8bba\u662f\u5426\u7ec4\u6210\u4e00\u7ec4\uff0c\u6700\u8d35\u7684\u7eaa\u5ff5\u54c1\u90fd\u5df2\u7ecf\u88ab\u5904\u7406\n        right--;\n        // \u5206\u7ec4\u6570\u52a0\u4e00\n        groups++;\n    }\n    \n    std::cout << groups << std::endl;\n    \n    return 0;\n}\n"
    },
    {
        "question_id": 68,
        "code_file": "\n#include <iostream>\n#include <vector>\n#include <string>\n#include <algorithm>\n\nusing namespace std;\n\nint main() {\n    int N, T;\n    cin >> N >> T;\n    string states;\n    cin >> states;\n\n    vector<pair<int, int>> interactions(T);\n    for (int i = 0; i < T; ++i) {\n        cin >> interactions[i].first >> interactions[i].second >> interactions[i].second;\n    }\n\n    // Sort interactions by time\n    sort(interactions.begin(), interactions.end());\n\n    // Find all possible patient zeros\n    vector<int> possible_patient_zeros;\n    for (int i = 0; i < N; ++i) {\n        if (states[i] == '1') {\n            possible_patient_zeros.push_back(i + 1);\n        }\n    }\n\n    // Try all possible values of K from 0 to T\n    int min_K = T;\n    int max_K = 0;\n    for (int K = 0; K <= T; ++K) {\n        bool valid = true;\n        vector<int> infected(N + 1, 0);\n        infected[possible_patient_zeros[0]] = K;\n\n        for (const auto& interaction : interactions) {\n            int t = interaction.first;\n            int x = interaction.second;\n            int y = interaction.third;\n\n            if (infected[x] > 0 && infected[x] <= K) {\n                infected[y] = min(infected[y], infected[x] + 1);\n            }\n            if (infected[y] > 0 && infected[y] <= K) {\n                infected[x] = min(infected[x], infected[y] + 1);\n            }\n        }\n\n        for (int i = 1; i <= N; ++i) {\n            if (states[i - 1] == '1' && infected[i] == 0) {\n                valid = false;\n                break;\n            }\n        }\n\n        if (valid) {\n            min_K = min(min_K, K);\n            max_K = max(max_K, K);\n        }\n    }\n\n    // Output the result\n    if (max_K == 0) {\n        cout << possible_patient_zeros.size() << \" 1 Infinity\" << endl;\n    } else {\n        cout << possible_patient_zeros.size() << \" \" << min_K << \" \" << max_K << endl;\n    }\n\n    return 0;\n}\n"
    },
    {
        "question_id": 69,
        "code_file": "\n#include <iostream>\n#include <algorithm>\nusing namespace std;\n\nint main() {\n    int a, b, x, y;\n    cin >> a >> b >> x >> y;\n\n    int direct_distance = abs(a - b); // \u76f4\u63a5\u8fd0\u8f93\u7684\u8ddd\u79bb\n    int teleport_distance = abs(a - x) + abs(x - y) + abs(y - b); // \u4f20\u9001\u95e8\u8fd0\u8f93\u7684\u8ddd\u79bb\n\n    cout << min(direct_distance, teleport_distance) << endl;\n\n    return 0;\n}\n"
    },
    {
        "question_id": 70,
        "code_file": "\n#include <iostream>\n#include <algorithm>\nusing namespace std;\n\nint main() {\n    int M, S, T;\n    cin >> M >> S >> T;\n\n    // \u521d\u59cb\u72b6\u6001\n    int time = 0; // \u82b1\u8d39\u7684\u65f6\u95f4\n    int maxDistance = 0; // \u80fd\u8d70\u7684\u6700\u8fdc\u8ddd\u79bb\n    int magic = M; // \u9b54\u6cd5\u503c\n\n    while (time < T) {\n        // \u6bcf\u79d2\u7684\u51b3\u7b56\n        if (magic >= 10 && S >= 60) {\n            // \u5982\u679c\u9b54\u6cd5\u503c\u8db3\u591f\u4e14\u8ddd\u79bb\u8db3\u591f\uff0c\u4f7f\u7528\u95ea\u70c1\u6cd5\u672f\n            magic -= 10;\n            S -= 60;\n            time++;\n        } else if (S >= 17) {\n            // \u5982\u679c\u8ddd\u79bb\u8db3\u591f\uff0c\u8dd1\u6b65\n            S -= 17;\n            magic = min(magic + 4, 1000); // \u9b54\u6cd5\u503c\u6062\u590d\uff0c\u4f46\u4e0d\u8d85\u8fc71000\n            time++;\n        } else {\n            // \u5982\u679c\u9b54\u6cd5\u503c\u4e0d\u591f\u4e14\u8ddd\u79bb\u4e0d\u591f\uff0c\u4f11\u606f\n            magic = min(magic + 4, 1000); // \u9b54\u6cd5\u503c\u6062\u590d\uff0c\u4f46\u4e0d\u8d85\u8fc71000\n            time++;\n        }\n\n        // \u66f4\u65b0\u80fd\u8d70\u7684\u6700\u8fdc\u8ddd\u79bb\n        maxDistance = max(maxDistance, S + magic / 4 * 17);\n    }\n\n    // \u5224\u65ad\u662f\u5426\u80fd\u9003\u79bb\u8352\u5c9b\n    if (S <= 0) {\n        cout << \"Yes\" << endl;\n        cout << time - 1 << endl;\n    } else {\n        cout << \"No\" << endl;\n        cout << maxDistance << endl;\n    }\n\n    return 0;\n}\n"
    },
    {
        "question_id": 71,
        "code_file": "\n#include <iostream>\n#include <vector>\n#include <unordered_map>\n#include <queue>\n\nusing namespace std;\n\nstruct Ship {\n    int arrival_time;\n    int num_passengers;\n    vector<int> nationalities;\n};\n\nint main() {\n    int n;\n    cin >> n;\n    vector<Ship> ships(n);\n\n    for (int i = 0; i < n; ++i) {\n        cin >> ships[i].arrival_time >> ships[i].num_passengers;\n        ships[i].nationalities.resize(ships[i].num_passengers);\n        for (int j = 0; j < ships[i].num_passengers; ++j) {\n            cin >> ships[i].nationalities[j];\n        }\n    }\n\n    queue<int> ship_queue;\n    unordered_map<int, int> nationality_count;\n    int unique_nationalities = 0;\n\n    for (int i = 0; i < n; ++i) {\n        // Add the current ship to the queue\n        ship_queue.push(i);\n\n        // Add passengers of the current ship to the nationality count\n        for (int nationality : ships[i].nationalities) {\n            if (nationality_count[nationality]++ == 0) {\n                unique_nationalities++;\n            }\n        }\n\n        // Remove ships from the queue that are older than 24 hours\n        while (!ship_queue.empty() && ships[i].arrival_time - ships[ship_queue.front()].arrival_time >= 86400) {\n            int ship_index = ship_queue.front();\n            ship_queue.pop();\n\n            // Remove passengers of the removed ship from the nationality count\n            for (int nationality : ships[ship_index].nationalities) {\n                if (--nationality_count[nationality] == 0) {\n                    unique_nationalities--;\n                }\n            }\n        }\n\n        // Output the number of unique nationalities for the current ship\n        cout << unique_nationalities << endl;\n    }\n\n    return 0;\n}\n"
    },
    {
        "question_id": 72,
        "code_file": "\n#include <iostream>\nusing namespace std;\n\nint main() {\n    int n, x;\n    cin >> n >> x;\n    int count = 0;\n\n    for (int i = 1; i <= n; ++i) {\n        int num = i;\n        while (num > 0) {\n            if (num % 10 == x) {\n                ++count;\n            }\n            num /= 10;\n        }\n    }\n\n    cout << count << endl;\n    return 0;\n}\n"
    },
    {
        "question_id": 73,
        "code_file": "\n#include <iostream>\n#include <vector>\nusing namespace std;\n\nconst int MOD = 20123;\n\nint main() {\n    int N, M;\n    cin >> N >> M;\n\n    vector<vector<pair<int, int>>> rooms(N + 1, vector<pair<int, int>>(M));\n    for (int i = 1; i <= N; ++i) {\n        for (int j = 0; j < M; ++j) {\n            cin >> rooms[i][j].first >> rooms[i][j].second;\n        }\n    }\n\n    int startRoom;\n    cin >> startRoom;\n\n    int currentFloor = 1;\n    int currentRoom = startRoom;\n    int key = 0;\n\n    while (currentFloor <= N) {\n        key = (key + rooms[currentFloor][currentRoom].second) % MOD;\n\n        int countStairs = 0;\n        int nextRoom = currentRoom;\n        do {\n            if (rooms[currentFloor][nextRoom].first == 1) {\n                ++countStairs;\n            }\n            if (countStairs == rooms[currentFloor][currentRoom].second) {\n                break;\n            }\n            nextRoom = (nextRoom + 1) % M;\n        } while (nextRoom != currentRoom);\n\n        currentRoom = nextRoom;\n        ++currentFloor;\n    }\n\n    cout << key << endl;\n\n    return 0;\n}\n"
    },
    {
        "question_id": 74,
        "code_file": "\n#include <iostream>\n#include <vector>\n#include <cmath>\n#include <algorithm>\n\nusing namespace std;\n\nint main() {\n    int n;\n    cin >> n;\n    vector<int> c(n);\n    for (int i = 0; i < n; ++i) {\n        cin >> c[i];\n    }\n\n    int m, p1, s1, s2;\n    cin >> m >> p1 >> s1 >> s2;\n\n    // \u66f4\u65b0p1\u53f7\u5175\u8425\u7684\u5de5\u5175\u6570\u91cf\n    c[p1 - 1] += s1;\n\n    // \u8ba1\u7b97\u521d\u59cb\u7684\u9f99\u65b9\u548c\u864e\u65b9\u7684\u6c14\u52bf\n    long long dragonPower = 0, tigerPower = 0;\n    for (int i = 0; i < m - 1; ++i) {\n        dragonPower += c[i] * (m - i - 1);\n    }\n    for (int i = m; i < n; ++i) {\n        tigerPower += c[i] * (i - m + 1);\n    }\n\n    // \u521d\u59cb\u5316\u6700\u5c0f\u6c14\u52bf\u5dee\u548c\u6700\u4f18\u5175\u8425\u4f4d\u7f6e\n    long long minPowerDiff = LLONG_MAX;\n    int bestPosition = 0;\n\n    // \u5c1d\u8bd5\u5c06s2\u4f4d\u5de5\u5175\u653e\u7f6e\u5728\u6bcf\u4e2a\u5175\u8425\u4e2d\n    for (int i = 0; i < n; ++i) {\n        long long newDragonPower = dragonPower;\n        long long newTigerPower = tigerPower;\n\n        if (i < m - 1) {\n            newDragonPower += s2 * (m - i - 1);\n        } else if (i > m - 1) {\n            newTigerPower += s2 * (i - m + 1);\n        }\n\n        long long powerDiff = abs(newDragonPower - newTigerPower);\n        if (powerDiff < minPowerDiff) {\n            minPowerDiff = powerDiff;\n            bestPosition = i + 1;\n        }\n    }\n\n    // \u8f93\u51fa\u6700\u4f18\u5175\u8425\u4f4d\u7f6e\n    cout << bestPosition << endl;\n\n    return 0;\n}\n"
    },
    {
        "question_id": 75,
        "code_file": "\n#include <iostream>\n#include <string>\n#include <algorithm>\n\nusing namespace std;\n\nint main() {\n    string target, article;\n    getline(cin, target);\n    getline(cin, article);\n\n    // \u5c06\u76ee\u6807\u5355\u8bcd\u548c\u6587\u7ae0\u90fd\u8f6c\u6362\u4e3a\u5c0f\u5199\uff0c\u4ee5\u4fbf\u4e0d\u533a\u5206\u5927\u5c0f\u5199\u5339\u914d\n    transform(target.begin(), target.end(), target.begin(), ::tolower);\n    transform(article.begin(), article.end(), article.begin(), ::tolower);\n\n    int count = 0;\n    size_t pos = article.find(target);\n    int firstPos = -1;\n\n    // \u67e5\u627e\u76ee\u6807\u5355\u8bcd\u5728\u6587\u7ae0\u4e2d\u7684\u51fa\u73b0\u6b21\u6570\u548c\u7b2c\u4e00\u6b21\u51fa\u73b0\u7684\u4f4d\u7f6e\n    while (pos != string::npos) {\n        // \u68c0\u67e5\u662f\u5426\u662f\u72ec\u7acb\u5355\u8bcd\n        if ((pos == 0 || article[pos - 1] == ' ') && \n            (pos + target.length() == article.length() || article[pos + target.length()] == ' ')) {\n            count++;\n            if (firstPos == -1) {\n                firstPos = pos;\n            }\n        }\n        pos = article.find(target, pos + 1);\n    }\n\n    // \u8f93\u51fa\u7ed3\u679c\n    if (count > 0) {\n        cout << count << \" \" << firstPos << endl;\n    } else {\n        cout << -1 << endl;\n    }\n\n    return 0;\n}\n"
    },
    {
        "question_id": 76,
        "code_file": "\n#include <iostream>\n#include <vector>\n#include <algorithm>\n\nusing namespace std;\n\nint main() {\n    int N;\n    cin >> N;\n    vector<int> positions(N);\n    for (int i = 0; i < N; ++i) {\n        cin >> positions[i];\n    }\n\n    // Sort the positions to easily find the closest cows\n    sort(positions.begin(), positions.end());\n\n    // The minimum number of balls needed is the number of cows divided by 2\n    // because each ball can start a chain of at least 2 cows receiving the ball.\n    int min_balls = N / 2;\n\n    // However, we need to ensure that all cows receive the ball.\n    // We can do this by placing balls at the two extreme positions.\n    // This ensures that the ball can reach all other cows.\n    cout << min_balls << endl;\n\n    return 0;\n}\n"
    }
]